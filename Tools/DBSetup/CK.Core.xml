<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CK.Core</name>
    </assembly>
    <members>
        <member name="T:CK.Core.AppSettings">
            <summary>
            Very simple facade for simple application settings.
            This does not handle multiple configurations per key (like ConfigurationManager.AppSettings can do since it is a NameValueCollection) but
            can expose potentially complex configuration objects instead of only strings.
            It can be initialized only once, before any other access, and when not initialized tries to automatically use the standard ConfigurationManager.AppSettings 
            through late binding. However, it supports multiple overriding and reverting to the original configuration. 
            (Override support and restoration is mainly designed for tests but the override functionality alone can be a useful feature in real life application.)
            </summary>
        </member>
        <member name="F:CK.Core.AppSettings.Default">
            <summary>
            Gets the default, singleton, AppSettings object.
            </summary>
        </member>
        <member name="M:CK.Core.AppSettings.Initialize(System.Func{System.String,System.Object})">
            <summary>
            Initializes this <see cref="T:CK.Core.AppSettings"/> object. This can be called only once
            prior to any use of this object.
            When not called before the first access, the .Net ConfigurationManager.AppSettings is used if possible (late binding).
            </summary>
            <param name="getConfigurationObject">The function that ultimately </param>
        </member>
        <member name="M:CK.Core.AppSettings.Override(System.Func{System.Func{System.String,System.Object},System.String,System.Object})">
            <summary>
            Overrides this <see cref="T:CK.Core.AppSettings"/> object configuration function. This can be called after <see cref="M:CK.Core.AppSettings.Initialize(System.Func{System.String,System.Object})"/> or <see cref="M:CK.Core.AppSettings.DefaultInitialize"/>
            or directly: any access to the configuration since any access triggers a call to DefaultInitialize.
            The function that overrides the current configuration is called with the previously active function to enable chaining (filtering, alteration of the keys and or the values).
            </summary>
            <param name="filterConfigurationObject">The function that ultimately </param>
        </member>
        <member name="M:CK.Core.AppSettings.RevertOverrides">
            <summary>
            Reverts all calls to <see cref="M:CK.Core.AppSettings.Override(System.Func{System.Func{System.String,System.Object},System.String,System.Object})"/>: the initial configuration is restored.
            </summary>
        </member>
        <member name="P:CK.Core.AppSettings.IsInitialzed">
            <summary>
            Gets whether this AppSettings object has been initialized.
            It can be initialized only once.
            </summary>
        </member>
        <member name="M:CK.Core.AppSettings.DefaultInitialize">
            <summary>
            Automatically bind to standard ConfigurationManager.AppSettings to obtain configuration strings.
            This method is automatically called when this object is not yet initialized on any access other than <see cref="M:CK.Core.AppSettings.Initialize(System.Func{System.String,System.Object})"/>.
            </summary>
        </member>
        <member name="P:CK.Core.AppSettings.Item(System.String)">
            <summary>
            Gets the settings as a string: <see cref="M:System.Object.ToString"/> is called on object.
            Null if the key is not found.
            </summary>
            <param name="key">The configuration key.</param>
            <returns>The string (object expressed as a string) or null if no such configuration exists.</returns>
        </member>
        <member name="M:CK.Core.AppSettings.Get(System.String)">
            <summary>
            Gets the settings as an object.
            </summary>
            <param name="key">The configuration key.</param>
            <returns>The configured available object or null if no such configuration exists.</returns>
        </member>
        <member name="M:CK.Core.AppSettings.Get``1(System.String,``0)">
            <summary>
            Gets the settings as a typed object: if the object is not available or is not of the given type, the default value is returned;
            </summary>
            <param name="key">The configuration key.</param>
            <param name="defaultValue">The default value to return if no object exists.</param>
            <returns>The configured available object or the <paramref name="defaultValue"/> if no such configuration exists.</returns>
        </member>
        <member name="M:CK.Core.AppSettings.GetRequired(System.String)">
            <summary>
            Gets the settings as an object: if the object is not available, an exception is thrown.
            </summary>
            <param name="key">The configuration key.</param>
            <returns>The configured available object.</returns>
        </member>
        <member name="M:CK.Core.AppSettings.GetRequired``1(System.String)">
            <summary>
            Gets the settings as a typed object: if the object is not available or is not of the given type, an exception is thrown.
            </summary>
            <param name="key">The configuration key.</param>
            <returns>The configured available object.</returns>
        </member>
        <member name="T:CK.Core.CKException">
            <summary>
            Basic <see cref="T:System.Exception"/> that eases message formatting thanks to its constructors
            and provides an Exception wrapper around <see cref="T:CK.Core.CKExceptionData"/>.
            </summary>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKException"/>.
            </summary>
            <param name="message">Simple message.</param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKException"/>.
            </summary>
            <param name="message">Simple message.</param>
            <param name="innerException">Exception that caused this one.</param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKException"/>.
            </summary>
            <param name="messageFormat">Format string with optional placeholders.</param>
            <param name="args">Varying number of arguments to format.</param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.Exception,System.String,System.Object[])">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKException"/> with an <see cref="P:System.Exception.InnerException"/>.
            </summary>
            <param name="innerException">Exception that caused this one.</param>
            <param name="messageFormat">Format string with optional placeholders.</param>
            <param name="args">Varying number of arguments to format.</param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(CK.Core.CKExceptionData)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKException"/> with an <see cref="P:CK.Core.CKException.ExceptionData"/>.
            The message of this exception is the <see cref="P:CK.Core.CKExceptionData.Message"/>.
            Use the static <see cref="M:CK.Core.CKException.CreateFrom(CK.Core.CKExceptionData)"/> to handle null data (a null CKException will be returned).
            </summary>
            <param name="data">The exception data. Must not be null.</param>
        </member>
        <member name="M:CK.Core.CKException.CreateFrom(CK.Core.CKExceptionData)">
            <summary>
            Creates a <see cref="T:CK.Core.CKException"/> from a <see cref="T:CK.Core.CKExceptionData"/>. This method returns null when data is null.
            This is the symmetric of <see cref="M:CK.Core.CKExceptionData.CreateFrom(System.Exception)"/>.
            </summary>
            <param name="data">Data of an exception for which a <see cref="T:CK.Core.CKException"/> wrapper must be created. Can be null: null is returned.</param>
            <returns>The exception that wraps the data.</returns>
        </member>
        <member name="P:CK.Core.CKException.ExceptionData">
            <summary>
            Gets the <see cref="T:CK.Core.CKExceptionData"/> if it exists: use <see cref="M:CK.Core.CKException.EnsureExceptionData"/> to 
            create if this is null, a data that describes this exception.
            </summary>
        </member>
        <member name="M:CK.Core.CKException.EnsureExceptionData">
            <summary>
            If <see cref="P:CK.Core.CKException.ExceptionData"/> is null, this method creates the <see cref="T:CK.Core.CKExceptionData"/> with the details
            from this exception.
            </summary>
            <returns>The <see cref="T:CK.Core.CKExceptionData"/> that describes this exception.</returns>
        </member>
        <member name="T:CK.Core.CKException.SerialData">
            <summary>
            Implements the ISafeSerializationData interface: this is the recommended way starting with .Net 4 
            to be able to use this in partially trusted environment (the GetObjectData method is now marked with the SecurityCriticalAttribute).
            </summary>
        </member>
        <member name="F:CK.Core.CKException.SerialData.ExData">
            <summary>
            The exception data from <see cref="T:CK.Core.CKException"/> that must be serialized.
            </summary>
        </member>
        <member name="T:CK.Core.CKExceptionData">
            <summary>
            Immutable and serializable representation of an exception.
            It contains specific data for some exceptions that, based on our experience, are actually interesting.
            </summary>
        </member>
        <member name="M:CK.Core.CKExceptionData.#ctor(System.String,System.String,System.String,System.String,CK.Core.CKExceptionData,System.String,System.String,CK.Core.CKExceptionData[],CK.Core.CKExceptionData[])">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKExceptionData"/> with all its fields.
            Use the factory method <see cref="M:CK.Core.CKExceptionData.CreateFrom(System.Exception)"/> to create a data from any exception.
            </summary>
            <param name="message">Message of the exception. Must not be null.</param>
            <param name="exceptionTypeName">Type name of the exception (no namespace nor assembly). Must not be null nor empty..</param>
            <param name="exceptionTypeAssemblyQualifiedName">Full type name of the exception. Must not be null nor empty.</param>
            <param name="stackTrace">Stack trace. Can be null.</param>
            <param name="innerException">Inner exception. If <paramref name="aggregatedExceptions"/> is not null, it must be the same as the first aggregated exceptions.</param>
            <param name="fileName">File name related to the exception (if it makes sense). Can be null.</param>
            <param name="detailedInfo">More detailed information if any.</param>
            <param name="loaderExceptions">Loader exceptions. <see cref="P:CK.Core.CKExceptionData.LoaderExceptions"/>.</param>
            <param name="aggregatedExceptions">Aggregated exceptions can be null. Otherwise, it must contain at least one exception.</param>
        </member>
        <member name="M:CK.Core.CKExceptionData.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKExceptionData"/> from a <see cref="T:System.IO.BinaryReader"/>. 
            See <see cref="M:CK.Core.CKExceptionData.Write(System.IO.BinaryWriter)"/>.
            </summary>
            <param name="r">The reader to read from.</param>
        </member>
        <member name="M:CK.Core.CKExceptionData.CreateFrom(System.Exception)">
            <summary>
            Creates a <see cref="T:CK.Core.CKExceptionData"/> from any <see cref="T:System.Exception"/>.
            </summary>
            <param name="ex">Exception for which data must be created. Can be null: null is returned.</param>
            <returns>The data that describes the exception.</returns>
        </member>
        <member name="P:CK.Core.CKExceptionData.Message">
            <summary>
            Gets the message of the exception. Never null but can be empty.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.ExceptionTypeAssemblyQualifiedName">
            <summary>
            Gets the assembly qualified exception type name. Never null nor empty.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.ExceptionTypeName">
            <summary>
            Gets the exception type name. Never null nor empty.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.StackTrace">
            <summary>
            Gets the stack trace. Can be null.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.InnerException">
            <summary>
            Gets the inner exception if it exists.
            If <see cref="P:CK.Core.CKExceptionData.AggregatedExceptions"/> is not null, it is the same as the first aggreated exceptions.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.FileName">
            <summary>
            Gets the file name if the exception is referring to a file. 
            Null otherwise.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.DetailedInfo">
            <summary>
            Gets more information: this depends on the actual exception type.
            For instance, if the exception is a <see cref="T:System.IO.FileNotFoundException"/> or a <see cref="T:System.IO.FileLoadException"/> that was raised
            while dynamically loading a type or an assembly and we are in DNX, this contains the log from Fusion assembly loading subsystem. 
            Null otherwise.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.LoaderExceptions">
            <summary>
            Gets all the the exceptions that occurred while dynamically loading a type or an assembly if the exception is a <see cref="T:System.Reflection.ReflectionTypeLoadException"/>.
            Null otherwise.
            </summary>
        </member>
        <member name="P:CK.Core.CKExceptionData.AggregatedExceptions">
            <summary>
            Gets all the the aggregated exceptions if the exception is a <see cref="T:System.AggregateException"/>.
            This corresponds to the <see cref="P:System.AggregateException.InnerExceptions"/> property.
            Null if this exception is not a an AggregatedException.
            </summary>
        </member>
        <member name="M:CK.Core.CKExceptionData.Write(System.IO.BinaryWriter)">
            <summary>
            Writes this exception data into a <see cref="T:System.IO.BinaryWriter"/>.
            </summary>
            <param name="w">The writer to use. Can not be null.</param>
        </member>
        <member name="M:CK.Core.CKExceptionData.ToTextWriter(System.IO.TextWriter,System.String,System.String)">
            <summary>
            Writes the exception data as a readable block of text into a <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="w">The TextWriter to write to.</param>
            <param name="prefix">Prefix that will appear at the start of each line.</param>
            <param name="newLine">Defaults to <see cref="P:System.Environment.NewLine"/>.</param>
        </member>
        <member name="M:CK.Core.CKExceptionData.ToStringBuilder(System.Text.StringBuilder,System.String,System.String)">
            <summary>
            Writes the exception data as a readable block of text into a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="b">The StringBuilder to write to.</param>
            <param name="prefix">Prefix that will appear at the start of each line.</param>
            <param name="newLine">Defaults to <see cref="P:System.Environment.NewLine"/>.</param>
        </member>
        <member name="M:CK.Core.CKExceptionData.WriteText(System.Action{System.String},System.String,System.String)">
            <summary>
            Core function that writes the exception data as a readable block of text.
            </summary>
            <param name="appender">The function that collects the text fragments.</param>
            <param name="prefix">Prefix that will appear at the start of each line.</param>
            <param name="newLine">Defaults to <see cref="P:System.Environment.NewLine"/>.</param>
        </member>
        <member name="M:CK.Core.CKExceptionData.ToString">
            <summary>
            Overridden to return the result of <see cref="M:CK.Core.CKExceptionData.WriteText(System.Action{System.String},System.String,System.String)"/> without prefix and a standard <see cref="P:System.Environment.NewLine"/>.
            This is cached once built.
            </summary>
            <returns>This exception data as a block of readable text.</returns>
        </member>
        <member name="T:CK.Core.CKSortedArrayKeyList`2">
            <summary>
            Sorted list of items where the sort order relies on an external key, not the item itself.
            </summary>.
        </member>
        <member name="P:CK.Core.CKSortedArrayKeyList`2.DebuggerView.Items">
            <summary>
            Gets the items as a flattened array view.
            </summary>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.#ctor(System.Func{`0,`1},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKSortedArrayKeyList`2"/>.
            </summary>
            <param name="keySelector">Function that associates a key to an item.</param>
            <param name="allowDuplicates">True to allow duplicates.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.#ctor(System.Func{`0,`1},System.Comparison{`1},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKSortedArrayKeyList`2"/> where a <see cref="T:System.Comparison`1"/> function
            is used to compare keys.
            </summary>
            <param name="keySelector">Function that associates a key to an item.</param>
            <param name="keyComparison">Function used to compare keys.</param>
            <param name="allowDuplicates">True to allow duplicates.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.IndexOf(`1)">
            <summary>
            Gets the zero based position of on of the items that is associated to this key.
            </summary>
            <param name="key">The key to find.</param>
            <returns>The index or a negative value like <see cref="G:Util.BinarySearch{T,TKey}"/>.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.Contains(`1)">
            <summary>
            True if this list contains at least one item with the given key.
            </summary>
            <param name="key">The key to find.</param>
            <returns>True if an item is found, false otherwise.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.GetByKey(`1,System.Boolean@)">
            <summary>
            Gets the first item with a given key or the default value if no such item exist.
            </summary>
            <param name="key">The key.</param>
            <param name="exists">True if the key has been found, otherwise false.</param>
            <returns>The item or default(T) if not found.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.KeyCount(`1)">
            <summary>
            Gets the number of items with a given key. It can be greater than 1 only if <see cref="P:CK.Core.CKSortedArrayList`1.AllowDuplicates">AllowDuplicates</see> is true.
            </summary>
            <param name="key">The key to find.</param>
            <returns>The number of item with the <paramref name="key"/>.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.GetAllByKey(`1)">
            <summary>
            Gets an independent collection of the items that 
            are associated to the given key value.
            </summary>
            <param name="key">The key to find.</param>
            <returns>An independent collection of <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.IndexOf(`0)">
            <summary>
            Gets the index of the element thanks to a linear search into the 
            internal array.
            If the key did not change, it is more efficient to find an element with <see cref="M:CK.Core.CKSortedArrayKeyList`2.IndexOf(`1)"/> that 
            uses a dichotomic search.
            </summary>
            <param name="value">The element to locate.</param>
            <returns>The index in array that, if found; otherwise, â€“1.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.IndexOf(System.Object)">
            <summary>
            Covariant IndexOf method: if <paramref name="item"/> is of type <typeparamref name="T"/>
            the linear <see cref="M:CK.Core.CKSortedArrayKeyList`2.IndexOf(`0)"/> is used but if <paramref name="item"/> is of type <typeparamref name="TKey"/>,
            the logarithmic <see cref="M:CK.Core.CKSortedArrayKeyList`2.IndexOf(`1)"/> is used.
            </summary>
            <param name="item">Can be a <typeparamref name="T"/> or a <typeparamref name="TKey"/>.</param>
            <returns>The index of the item in the collection.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.Contains(System.Object)">
            <summary>
            Covariant version of the contains predicate. 
            If <paramref name="item"/> is of type <typeparamref name="T"/> the <see cref="M:CK.Core.CKSortedArrayList`1.Contains(`0)"/> is used 
            but if <paramref name="item"/> is of type <typeparamref name="TKey"/>, the <see cref="M:CK.Core.CKSortedArrayKeyList`2.Contains(`1)"/> is used.
            </summary>
            <param name="item">Can be a <typeparamref name="T"/> or a <typeparamref name="TKey"/>.</param>
            <returns>True if a corresponding element in this list can be found.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayKeyList`2.Remove(`1)">
            <summary>
            Removes one item given a key: only one item is removed when <see cref="P:CK.Core.CKSortedArrayList`1.AllowDuplicates"/> is 
            true and more than one item are associated to this key.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>True if an item has been removed, false otherwise.</returns>
        </member>
        <member name="T:CK.Core.CKReadOnlyListOnIList`1">
            <summary>
            Small adapter that exposes a <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> on a <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="T">Type of the list's items.</typeparam>
        </member>
        <member name="M:CK.Core.CKReadOnlyListOnIList`1.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKReadOnlyListOnIList`1"/> with a null <see cref="P:CK.Core.CKReadOnlyListOnIList`1.Values"/>.
            </summary>
        </member>
        <member name="M:CK.Core.CKReadOnlyListOnIList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKReadOnlyListOnIList`1"/> on a <see cref="T:System.Collections.Generic.IList`1"/>
            for the <see cref="P:CK.Core.CKReadOnlyListOnIList`1.Values"/>.
            </summary>
            <param name="values">List to wrap.</param>
        </member>
        <member name="P:CK.Core.CKReadOnlyListOnIList`1.Values">
            <summary>
            Gets or sets the wrapped collection.
            </summary>
        </member>
        <member name="P:CK.Core.CKReadOnlyListOnIList`1.Count">
            <summary>
            Gets the count of items.
            </summary>
        </member>
        <member name="P:CK.Core.CKReadOnlyListOnIList`1.Item(System.Int32)">
            <summary>
            Gets the item at a given index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyListOnIList`1.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns>An enumerator on the <see cref="P:CK.Core.CKReadOnlyListOnIList`1.Values"/>.</returns>
        </member>
        <member name="T:CK.Core.CKSortedArrayList`1">
            <summary>
            Simple sorted array list implementation that supports covariance through <see cref="T:CK.Core.ICKReadOnlyList`1"/> and contra-variance 
            with <see cref="T:CK.Core.ICKWritableCollection`1"/>. This is a "dangerous" class since to keep the correct ordering, <see cref="M:CK.Core.CKSortedArrayList`1.CheckPosition(System.Int32)"/> 
            must be explicitly called whenever something changes on any item that impacts the <see cref="F:CK.Core.CKSortedArrayList`1.Comparator"/> result.
            See the remarks for other caveats.
            </summary>
            <remarks>
            <para>
            This class implements <see cref="T:System.Collections.Generic.IList`1"/> both for performance (unfortunately Linq relies -too much- on it) and for interoperability reasons: this
            interface should NOT be used. Accessors of the <see cref="T:System.Collections.Generic.IList`1"/> that defeats the invariant of this class (the fact that elements are sorted, such 
            as <see cref="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)"/>) are explicitly implemented to hide them as much as possible.
            </para>
            <para>
            This is the base class for <see cref="T:CK.Core.CKSortedArrayKeyList`2"/>.
            </para>
            <para>
            Specialized classes may use protected <see cref="P:CK.Core.CKSortedArrayList`1.Store"/>, <see cref="P:CK.Core.CKSortedArrayList`1.StoreCount"/> and <see cref="P:CK.Core.CKSortedArrayList`1.StoreVersion"/> to have a direct, uncontrolled, access
            to the whole state of this object.
            </para>
            </remarks>
        </member>
        <member name="F:CK.Core.CKSortedArrayList`1.Comparator">
            <summary>
            Specialized implementation can use this comparison function if needed.
            </summary>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKSortedArrayList`1"/> that rejects duplicates 
            and uses the <see cref="P:System.Collections.Generic.Comparer`1.Default"/> comparer.
            </summary>
            <remarks>
            A default constructor is a parameterless constructor, it is not the same as a constructor with default parameter values.
            This is why it is explicitly defined.
            </remarks>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.#ctor(System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKSortedArrayList`1"/> that rejects or allows duplicates 
            and uses the <see cref="P:System.Collections.Generic.Comparer`1.Default"/> comparer.
            </summary>
            <param name="allowDuplicates">True to allow duplicate elements.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.#ctor(System.Collections.Generic.IComparer{`0},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKSortedArrayList`1"/> that rejects or allows duplicates 
            and uses the given comparer.
            </summary>
            <param name="comparer">Comparer to use.</param>
            <param name="allowDuplicates">True to allow duplicate elements.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.#ctor(System.Comparison{`0},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKSortedArrayList`1"/> that rejects or allows duplicates 
            and uses the given comparison function.
            </summary>
            <param name="comparison">Comparison function to use.</param>
            <param name="allowDuplicates">True to allow duplicate elements.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Explicitly implemented since our <see cref="M:CK.Core.CKSortedArrayList`1.Add(`0)"/> method
            returns a boolean.
            </summary>
            <param name="item">Item to add.</param>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.AllowDuplicates">
            <summary>
            Gets whether this list allows duplicated items.
            </summary>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.IndexOf(`0)">
            <summary>
            Locates an element (one of the occurrences when duplicates are allowed) in this list (logarithmic). 
            </summary>
            <param name="value">The element.</param>
            <returns>The result of the <see cref="G:Util.BinarySearch{T}"/> in the internal array.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.IndexOf``1(``0,System.Func{`0,``0,System.Int32})">
            <summary>
            Binary search implementation that relies on an extended comparer: a function that knows how to 
            compare the elements of the array to its key. This function must work exactly like this <see cref="F:CK.Core.CKSortedArrayList`1.Comparator"/>
            but accepts a <typeparamref name="T"/> and the <typeparamref name="TKey"/> that is used to sort the items otherwise
            the result is undefined.
            </summary>
            <typeparam name="TKey">Type of the key.</typeparam>
            <param name="key">The value of the key.</param>
            <param name="comparison">The comparison function.</param>
            <returns>Same as <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: negative index if not found which is the bitwise complement of (the index of the next element plus 1).</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.Contains(`0)">
            <summary>
            Determines whether this <see cref="T:CK.Core.CKSortedArrayList`1"/> contains a specific value (logarithmic).
            </summary>
            <param name="value">The value.</param>
            <returns>True if the object is found; otherwise, false.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.IndexOf(System.Object)">
            <summary>
            Covariant compatible overload of <see cref="M:CK.Core.CKSortedArrayList`1.IndexOf(`0)"/>  (logarithmic).
            If the item is not <typeparamref name="T"/> compatible, the 
            value <see cref="F:System.Int32.MinValue"/> is returned. See <see cref="M:CK.Core.ICKReadOnlyList`1.IndexOf(System.Object)"/>.
            </summary>
            <param name="item">The item to locate.</param>
            <returns>
            Positive index when found, negative one when not found and <see cref="F:System.Int32.MinValue"/> 
            if the item can structurally NOT appear in this list.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.Contains(System.Object)">
            <summary>
            Covariant compatible overload of <see cref="M:CK.Core.CKSortedArrayList`1.Contains(`0)"/>  (logarithmic).
            </summary>
            <param name="item">The item to find.</param>
            <returns>True if the object is found; otherwise, false.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the content of the internal array into the given array.
            </summary>
            <param name="array">Destination array.</param>
            <param name="arrayIndex">Index at which copying must start.</param>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.Count">
            <summary>
            Gets the number of elements in this sorted list.
            </summary>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Explicit implementation that always returns false.
            </summary>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.Remove(`0)">
            <summary>
            Removes a value and returns true if found; otherwise returns false.
            </summary>
            <param name="value">The value to remove.</param>
            <returns>True if the value has been found and removed, false otherwise.</returns>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.Capacity">
            <summary>
            Gets or sets the current capacity of the internal array.
            When setting it, if the new capacity is less than the current <see cref="P:CK.Core.CKSortedArrayList`1.Count"/>, 
            an <see cref="T:System.ArgumentException"/> is thrown.
            </summary>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.Item(System.Int32)">
            <summary>
            Gets the object at the given index.
            </summary>
            <param name="index">Zero based position of the item in this list.</param>
            <returns>The item.</returns>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.System#Collections#Generic#IList{T}#Item(System.Int32)">
            <summary>
            Explicit implementation to hide it as much as possible. 
            The setter calls the protected virtual <see cref="M:CK.Core.CKSortedArrayList`1.DoSet(System.Int32,`0)"/> method
            that does the job of actually setting the item at the given index... 
            even if this breaks the sort.
            </summary>
            <param name="index">Index of the item.</param>
            <returns>The item.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <summary>
            Explicit implementation to hide it as much as possible. 
            It calls the protected virtual <see cref="M:CK.Core.CKSortedArrayList`1.DoInsert(System.Int32,`0)"/> method
            that does the job of actually inserting the item at the given index... 
            even if this breaks the sort.
            </summary>
            <param name="index">Future index of the item.</param>
            <param name="value">Item to insert.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.Add(`0)">
            <summary>
            Adds the item at its right position depending on the comparison function and returns true.
            May return false if, for any reason, the item has not been added. At this level (but this 
            may be overridden), if <see cref="P:CK.Core.CKSortedArrayList`1.AllowDuplicates"/> is false and the item already exists,
            false is returned and the item is not added.
            </summary>
            <param name="value">Item to add.</param>
            <returns>True if the item has actually been added; otherwise false.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the given position.
            This is not virtual since it directly calls protected virtual <see cref="M:CK.Core.CKSortedArrayList`1.DoRemoveAt(System.Int32)"/>
            </summary>
            <param name="index">Index to remove.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.Clear">
            <summary>
            Clears the list.
            This is not virtual since it directly calls protected virtual <see cref="M:CK.Core.CKSortedArrayList`1.DoClear"/>
            </summary>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.CheckPosition(System.Int32)">
            <summary>
            Checks that the item at the given index is between a lesser and a greater item and if not, 
            moves the item at its correct index.
            If the new index conflicts because <see cref="P:CK.Core.CKSortedArrayList`1.AllowDuplicates"/> is false (the default), a 
            negative value is returned, otherwise the new positive index is returned.
            </summary>
            <param name="index">Index of the element to check.</param>
            <returns>
            The new positive index if the position has been successfully updated, or a negative value
            if a duplicate exists (and <see cref="P:CK.Core.CKSortedArrayList`1.AllowDuplicates"/> is false).
            </returns>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.Store">
            <summary>
            Direct access to the internal array to specialized classes.
            This must be used with care.
            </summary>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.StoreCount">
            <summary>
            Direct access to the <see cref="P:CK.Core.CKSortedArrayList`1.Count"/> to specialized classes.
            This must be used with care.
            </summary>
        </member>
        <member name="P:CK.Core.CKSortedArrayList`1.StoreVersion">
            <summary>
            Direct access to the internal version to specialized classes.
            LSB (StoreVersion &amp;  1) is <see cref="P:CK.Core.CKSortedArrayList`1.AllowDuplicates"/>: the version 
            is incremented by two whenever the content change.
            This must be used with care.
            </summary>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.DoSet(System.Int32,`0)">
            <summary>
            Sets a value at a given position.
            </summary>
            <param name="index">The position to set.</param>
            <param name="newValue">The new item to inject.</param>
            <returns>The previous item at the position.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.DoInsert(System.Int32,`0)">
            <summary>
            Inserts a new item.
            </summary>
            <param name="index">Index to insert.</param>
            <param name="value">Item to insert.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.DoClear">
            <summary>
            Clears the list.
            </summary>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.DoRemoveAt(System.Int32)">
            <summary>
            Removes the item at a given position.
            </summary>
            <param name="index">Index to remove.</param>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.DoMove(System.Int32,System.Int32)">
            <summary>
            Moves an item from a position to another one.
            </summary>
            <param name="from">Old index of the item.</param>
            <param name="newIndex">New index.</param>
            <returns>The new index of the element.</returns>
        </member>
        <member name="M:CK.Core.CKSortedArrayList`1.GetEnumerator">
            <summary>
            Gets an enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:CK.Core.CKTrait">
            <summary>
            A trait is an immutable object (thread-safe), associated to a unique string inside a <see cref="P:CK.Core.CKTrait.Context"/>, that can be atomic ("Alt", "Home", "Ctrl") or 
            combined ("Alt|Ctrl", "Alt|Ctrl|Home"). The only way to obtain a CKTrait is to call <see cref="M:CK.Core.CKTraitContext.FindOrCreate(System.String)"/> (from 
            a string) or to use one of the available combination methods (<see cref="M:CK.Core.CKTrait.Union(CK.Core.CKTrait)"/>, <see cref="M:CK.Core.CKTrait.Except(CK.Core.CKTrait)"/>, <see cref="M:CK.Core.CKTrait.SymmetricExcept(CK.Core.CKTrait)"/> or <see cref="M:CK.Core.CKTrait.Intersect(CK.Core.CKTrait)"/> ).
            </summary>
            <remarks>
            A CKTrait is not serializable: since it is relative to <see cref="T:CK.Core.CKTraitContext"/>, it must be recreated in the right context. A CKTraitContext is typically
            a static object that exists in the origin application domain. A CKTrait must be serialized as its <see cref="M:CK.Core.CKTrait.ToString"/> representation and it is up to the 
            code to call <see cref="M:CK.Core.CKTraitContext.FindOrCreate(System.String)"/> on the appropriate context when deserializing it.
            </remarks>
        </member>
        <member name="M:CK.Core.CKTrait.#ctor(CK.Core.CKTraitContext)">
            <summary>
            Initializes the new empty trait of a CKTraitContext.
            </summary>
        </member>
        <member name="M:CK.Core.CKTrait.#ctor(CK.Core.CKTraitContext,System.String)">
            <summary>
            Initializes a new atomic trait.
            </summary>
        </member>
        <member name="M:CK.Core.CKTrait.#ctor(CK.Core.CKTraitContext,System.String,System.Collections.Generic.IReadOnlyList{CK.Core.CKTrait})">
            <summary>
            Initializes a new combined trait.
            </summary>
        </member>
        <member name="P:CK.Core.CKTrait.Context">
            <summary>
            Gets the <see cref="T:CK.Core.CKTraitContext"/> to which this trait belongs. 
            </summary>
        </member>
        <member name="M:CK.Core.CKTrait.ToString">
            <summary>
            Gets the multi traits in an ordered manner separated by +.
            </summary>
            <returns>This multi trait as a string.</returns>
        </member>
        <member name="P:CK.Core.CKTrait.AtomicTraits">
            <summary>
            Gets the atomic traits that this trait contains.
            This list does not contain the empty trait and is sorted according to the name of the atomic traits (lexical order): this is the 
            same as the <see cref="M:CK.Core.CKTrait.ToString"/> representation.
            Note that it is in reverse order regarding <see cref="M:CK.Core.CKTrait.CompareTo(CK.Core.CKTrait)"/> ("A" that is stronger than "B" appears before "B").
            </summary>
        </member>
        <member name="P:CK.Core.CKTrait.IsEmpty">
            <summary>
            Gets a boolean indicating whether this trait is the empty trait (<see cref="P:CK.Core.CKTrait.AtomicTraits"/> is empty
            and <see cref="P:CK.Core.CKTrait.Fallbacks"/> contains only itself).
            </summary>
        </member>
        <member name="P:CK.Core.CKTrait.IsAtomic">
            <summary>
            Gets a boolean indicating whether this trait contains zero 
            (the empty trait is considered as an atomic trait) or only one atomic trait.
            </summary>
            <remarks>
            For atomic traits (and the empty trait itself), <see cref="P:CK.Core.CKTrait.Fallbacks"/> contains only the <see cref="P:CK.Core.CKTraitContext.EmptyTrait"/>.
            </remarks>
        </member>
        <member name="M:CK.Core.CKTrait.CompareTo(CK.Core.CKTrait)">
            <summary>
            Compares this trait with another one.
            The <see cref="P:CK.Core.CKTrait.Context"/> is the primary key (see <see cref="M:CK.Core.CKTraitContext.CompareTo(CK.Core.CKTraitContext)"/>), then comes 
            the number of traits (more traits is greater) and then comes the string representation of the trait in 
            reverse lexical order (<see cref="P:System.StringComparer.Ordinal"/>): "A" is greater than "B".
            </summary>
            <param name="other">The trait to compare to.</param>
            <returns>A negative, zero or positive value.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.Equals(CK.Core.CKTrait)">
            <summary>
            Checks equality of this trait with another one.
            </summary>
            <param name="other">The trait to compare to.</param>
            <returns>True on equality.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.IsSupersetOf(CK.Core.CKTrait)">
            <summary>
            Checks if each and every atomic traits of <paramref name="other" /> exists in this trait.
            </summary>
            <param name="other">The trait(s) to find.</param>
            <returns>True if all the specified traits appear in this trait.</returns>
            <remarks>
            Note that <see cref="P:CK.Core.CKTraitContext.EmptyTrait"/> is contained (in the sense of this IsSupersetOf method) by definition in any trait 
            (including itself): this is the opposite of the <see cref="M:CK.Core.CKTrait.Overlaps(CK.Core.CKTrait)"/> method.
            </remarks>
        </member>
        <member name="M:CK.Core.CKTrait.Overlaps(CK.Core.CKTrait)">
            <summary>
            Checks if one of the atomic traits of <paramref name="other" /> exists in this trait.
            </summary>
            <param name="other">The trait to find.</param>
            <returns>Returns true if one of the specified traits appears in this trait.</returns>
            <remarks>
            When true, this ensures that <see cref="M:CK.Core.CKTrait.Intersect(CK.Core.CKTrait)"/>( <paramref name="other"/> ) != <see cref="P:CK.Core.CKTraitContext.EmptyTrait"/>. 
            The empty trait is not contained (in the sense of this ContainsOne method) in any trait (including itself). This is the opposite
            of the <see cref="M:CK.Core.CKTrait.IsSupersetOf(CK.Core.CKTrait)"/> method.
            </remarks>
        </member>
        <member name="M:CK.Core.CKTrait.Intersect(CK.Core.CKTrait)">
            <summary>
            Obtains a <see cref="T:CK.Core.CKTrait"/> that contains the atomic traits from both this trait and <paramref name="other"/>.
            </summary>
            <param name="other">Trait that must be kept.</param>
            <returns>The resulting trait.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.Union(CK.Core.CKTrait)">
            <summary>
            Obtains a <see cref="T:CK.Core.CKTrait"/> that combines this one and 
            the trait(s) specified by the parameter. 
            </summary>
            <param name="other">Trait to add.</param>
            <returns>The resulting trait.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.Except(CK.Core.CKTrait)">
            <summary>
            Obtains a <see cref="T:CK.Core.CKTrait"/> from which trait(s) specified by the parameter are removed.
            </summary>
            <param name="other">Trait to remove.</param>
            <returns>The resulting trait.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.SymmetricExcept(CK.Core.CKTrait)">
            <summary>
            Obtains a <see cref="T:CK.Core.CKTrait"/> where the atomic traits of <paramref name="other" /> are removed (resp. added) depending 
            on whether they exist (resp. do not exist) in this trait. This is like an Exclusive Or (XOR).
            </summary>
            <param name="other">Trait to toggle.</param>
            <returns>The resulting trait.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.Apply(CK.Core.CKTrait,CK.Core.SetOperation)">
            <summary>
            Applies the given <see cref="T:CK.Core.SetOperation"/>.
            </summary>
            <param name="other">Trait to combine.</param>
            <param name="operation">Set operation.</param>
            <returns>Resulting trait.</returns>
        </member>
        <member name="M:CK.Core.CKTrait.Process(CK.Core.CKTrait,CK.Core.CKTrait,System.Func{CK.Core.CKTrait,System.Boolean},System.Func{CK.Core.CKTrait,System.Boolean},System.Func{CK.Core.CKTrait,System.Boolean})">
            <summary>
            Common process function where 3 predicates drive the result: each atomic trait is submitted to one of the 3 predicates
            depending on whether it is only in the left, only in the right or appears in both traits.
            When returning false, a predicate stops the process.
            </summary>
            <remarks>
            When this predicate is 'adding the trait to a list', we can draw the following table where '1' means the predicate exists and '0' means
            no predicate (or the 'always true' one):
            
                        0, 0, 0 =  -- 'Empty'
            Intersect   0, 0, 1 = Intersect (keep commons) => /Toggle
                        0, 1, 0 =  -- 'Cleanup' (keep theirs only) => /Remove 
                        0, 1, 1 =  -- 'Other' (keep theirs and commons, reject mine) => /This
            Except      1, 0, 0 = Remove (keep mine only) => /Cleanup
                        1, 0, 1 =  -- 'This' (keep mine and commons and reject theirs) => /Other
            Toggle      1, 1, 0 = Toggle (keep mine, theirs, but reject commons) => /Intersect
            Union       1, 1, 1 = Add
            
            This shows that our 4 methods Intersect, Remove, Toggle and Add cover the interesting cases - others are either symetric or useless.
            </remarks>
        </member>
        <member name="P:CK.Core.CKTrait.FallbacksCount">
            <summary>
            Gets the number of <see cref="P:CK.Core.CKTrait.Fallbacks"/>. It is 2^<see cref="P:CK.Core.CKTrait.AtomicTraits"/>.<see cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/> - 1 since this
            trait itself does not appear in the fallbacks, but it is always 1 for atomic and the empty trait (the empty trait always ends the list).
            </summary>
        </member>
        <member name="P:CK.Core.CKTrait.FallbacksLongCount">
            <summary>
            Gets the number of <see cref="P:CK.Core.CKTrait.Fallbacks"/>. It is 2^<see cref="P:CK.Core.CKTrait.AtomicTraits"/>.<see cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/> - 1 since this
            trait itself does not appear in the fallbacks, but it is always 1 for atomic and the empty trait (the empty trait always ends the list).
            </summary>
        </member>
        <member name="P:CK.Core.CKTrait.Fallbacks">
            <summary>
            Gets an enumeration of fallbacks to consider for this trait ordered from best to worst.
            This trait does not start the list but the <see cref="P:CK.Core.CKTraitContext.EmptyTrait"/> always ends this list.
            </summary>
            <remarks>
            For atomic traits (and the empty trait itself), <see cref="P:CK.Core.CKTrait.Fallbacks"/> contains only the <see cref="P:CK.Core.CKTraitContext.EmptyTrait"/>.
            </remarks>
        </member>
        <member name="T:CK.Core.CKTraitContext">
            <summary>
            Thread-safe registration root for <see cref="T:CK.Core.CKTrait"/> objects.
            </summary>
        </member>
        <member name="M:CK.Core.CKTraitContext.#ctor(System.String,System.Char)">
            <summary>
            Initializes a new context for traits with the given separator.
            </summary>
            <param name="name">Name for the context. Must not be null nor whitespace.</param>
            <param name="separator">Separator if it must differ from '|'.</param>
        </member>
        <member name="P:CK.Core.CKTraitContext.Separator">
            <summary>
            Gets the separator to use to separate combined traits. It is | by default.
            </summary>
        </member>
        <member name="P:CK.Core.CKTraitContext.Name">
            <summary>
            Gets the name of this context.
            </summary>
        </member>
        <member name="M:CK.Core.CKTraitContext.CompareTo(CK.Core.CKTraitContext)">
            <summary>
            Compares this context to another one.
            The key is <see cref="P:CK.Core.CKTraitContext.Separator"/>, then <see cref="P:CK.Core.CKTraitContext.Name"/> and if they are equal, a unique number is 
            used to order the two contexts.
            </summary>
            <param name="other">Context to compare.</param>
            <returns>0 for the exact same object (ReferenceEquals), greater/lower than 0 otherwise.</returns>
        </member>
        <member name="P:CK.Core.CKTraitContext.EmptyTrait">
            <summary>
            Gets the empty trait for this context. It corresponds to the empty string.
            </summary>
        </member>
        <member name="M:CK.Core.CKTraitContext.FindOrCreate(System.String)">
            <summary>
            Obtains a <see cref="T:CK.Core.CKTrait"/> (either combined or atomic).
            </summary>
            <param name="traits">Atomic trait or traits separated by <see cref="P:CK.Core.CKTraitContext.Separator"/>.</param>
            <returns>A trait.</returns>
        </member>
        <member name="M:CK.Core.CKTraitContext.FindIfAllExist(System.String)">
            <summary>
            Finds a <see cref="T:CK.Core.CKTrait"/> (either combined or atomic) only if all 
            of its atomic traits already exists: if any of the atomic traits are not already 
            registered, null is returned.
            </summary>
            <param name="traits">Atomic trait or traits separated by <see cref="P:CK.Core.CKTraitContext.Separator"/>.</param>
            <returns>A trait or null if the trait does not exists.</returns>
        </member>
        <member name="M:CK.Core.CKTraitContext.FindOnlyExisting(System.String,System.Func{System.String,System.Boolean})">
            <summary>
            Finds a <see cref="T:CK.Core.CKTrait"/> with only already existing atomic traits (null when not found).
            </summary>
            <param name="traits">Atomic trait or traits separated by <see cref="P:CK.Core.CKTraitContext.Separator"/>.</param>
            <param name="collector">Optional collector for unknown trait. As soon as the collector returns false, the process stops.</param>
            <returns>A trait that contains only already existing trait or null if none already exists.</returns>
        </member>
        <member name="P:CK.Core.CKTraitContext.EnumWithEmpty">
            <summary>
            Gets the fallback for empty and atomic traits.
            </summary>
        </member>
        <member name="M:CK.Core.CKTraitContext.FindOrCreate(System.Collections.Generic.List{CK.Core.CKTrait})">
            <summary>
            Obtains a trait from a list of atomic (already sorted) traits.
            Used by the Add, Toggle, Remove, Intersect methods.
            </summary>
        </member>
        <member name="M:CK.Core.CKTraitContext.FindOrCreate(CK.Core.CKTrait[],System.Int32)">
            <summary>
            Obtains a trait from a list of atomic (already sorted) traits.
            Used by fall back generation.
            </summary>
        </member>
        <member name="T:CK.Core.CKEnumeratorMono`1">
            <summary>
            Defines an optimized <see cref="T:System.Collections.Generic.IEnumerator`1"/> that contains
            only one element.
            </summary>
        </member>
        <member name="M:CK.Core.CKEnumeratorMono`1.#ctor(`0)">
            <summary>
            Initializes a new enumerator bound to one and only one value.
            </summary>
            <param name="val">Unique value that will be enumerated by this <see cref="T:CK.Core.CKEnumeratorMono`1"/></param>
        </member>
        <member name="P:CK.Core.CKEnumeratorMono`1.Current">
            <summary>
            Gets the strongly typed element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:CK.Core.CKEnumeratorMono`1.Dispose">
            <summary>
            Dispose the <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
        </member>
        <member name="M:CK.Core.CKEnumeratorMono`1.MoveNext">
            <summary>
            Move to the next element.
            </summary>
            <returns>True the first time, false otherwise</returns>
        </member>
        <member name="M:CK.Core.CKEnumeratorMono`1.Reset">
            <summary>
            Resets the enumerator.
            </summary>
        </member>
        <member name="T:CK.Core.CriticalErrorCollector">
            <summary>
            This collector keeps <see cref="P:CK.Core.CriticalErrorCollector.Capacity"/> <see cref="T:CK.Core.CriticalErrorCollector.Error"/>s (and no more).
            It raises <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/> event on each <see cref="M:CK.Core.CriticalErrorCollector.Add(System.Exception,System.String)"/>.
            It is totally thread-safe and guaranties (as long as its Capacity is big enough) that no error can be lost
            (even errors raised while dispatching the event are themselves collected) and that errors are dispatched in
            sequence.
            <para>
            This class is typically used as a static property or field by any object that must handle unexpected errors. (It can also be used
            per-instance if it makes sense.)
            </para>
            </summary>
        </member>
        <member name="T:CK.Core.CriticalErrorCollector.Error">
            <summary>
            Encapsulates error information <see cref="M:CK.Core.CriticalErrorCollector.Add(System.Exception,System.String)"/>ed by external code
            or raised by a <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/> event itself.
            </summary>
        </member>
        <member name="F:CK.Core.CriticalErrorCollector.Error.LostErrorCount">
            <summary>
            Holds the count of errors that have been discarded: too many critical errors occur
            in a too short time.
            When this field is greater than zero, this indicates a serious problem.
            </summary>
        </member>
        <member name="F:CK.Core.CriticalErrorCollector.Error.SequenceNumber">
            <summary>
            Unique, increasing, sequence number.
            </summary>
        </member>
        <member name="F:CK.Core.CriticalErrorCollector.Error.Comment">
            <summary>
            The origin or a description of the <see cref="P:Exception"/>.
            Never null but can be empty if no comment is provided while calling <see cref="M:CK.Core.CriticalErrorCollector.Add(System.Exception,System.String)"/>.
            </summary>
        </member>
        <member name="F:CK.Core.CriticalErrorCollector.Error.Exception">
            <summary>
            The exception.
            </summary>
        </member>
        <member name="M:CK.Core.CriticalErrorCollector.Error.ToString">
            <summary>
            Overridden to return <see cref="F:CK.Core.CriticalErrorCollector.Error.Comment"/> and <see cref="P:Exception"/> message.
            </summary>
            <returns>Explicit content.</returns>
        </member>
        <member name="T:CK.Core.CriticalErrorCollector.ErrorEventArgs">
            <summary>
            Event argument of <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/>.
            </summary>
        </member>
        <member name="F:CK.Core.CriticalErrorCollector.ErrorEventArgs.LoggingErrors">
            <summary>
            The <see cref="T:CK.Core.CriticalErrorCollector.Error"/>s. When more than one error exist, the oldest come first.
            </summary>
        </member>
        <member name="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads">
            <summary>
            Fires when an error has been <see cref="M:CK.Core.CriticalErrorCollector.Add(System.Exception,System.String)"/>ed (there cannot be more than one thread that raises this event at the same time).
            Raising this event is itself protected: if an exception is raised by one of the registered EventHandler, the culprit is removed 
            from the OnErrorFromBackgroundThreads list of delegates, the exception is appended in the collector, and a new event will 
            be raised (to the remaining handlers).
            <para>Caution: the event always fire on a background thread (adding an error is not a blocking operation).</para>
            </summary>
        </member>
        <member name="M:CK.Core.CriticalErrorCollector.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.CriticalErrorCollector"/> with a default <see cref="P:CK.Core.CriticalErrorCollector.Capacity"/> set to 128.
            </summary>
        </member>
        <member name="P:CK.Core.CriticalErrorCollector.Capacity">
            <summary>
            Gets or sets the maximal number of errors kept by this collector.
            Defaults to 128 (which should be enough).
            It can be safely changed at any time.
            </summary>
        </member>
        <member name="M:CK.Core.CriticalErrorCollector.Add(System.Exception,System.String)">
            <summary>
            Adds a critical, unexpected error.
            </summary>
            <param name="comment">Comment associated to the error (such as the name of the culprit). Can be null.</param>
            <param name="ex">The unexpected exception. Must not be null.</param>
        </member>
        <member name="M:CK.Core.CriticalErrorCollector.Clear(System.Int32@,System.Int32@)">
            <summary>
            Clears the list. Only errors that have been already raised by <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/>
            are removed from the internal buffer: it can be safely called at any time.
            </summary>
            <param name="cleared">Number of suppressed errors.</param>
            <param name="waitingToBeRaisedErrors">The number of errors waiting to be raised.</param>
        </member>
        <member name="M:CK.Core.CriticalErrorCollector.Clear">
            <summary>
            Clears the list. Only errors that have been already raised by <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/>
            are removed from the internal buffer: it can be safely called at any time.
            </summary>
        </member>
        <member name="P:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreadsPending">
            <summary>
            Gets whether any event is waiting to be raised by <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/> or is being processed.
            When this is false, it is guaranteed that any existing errors have been handled: if no more <see cref="M:CK.Core.CriticalErrorCollector.Add(System.Exception,System.String)"/> can be done
            it means that this collector has finished its job.
            Instead of pooling this property - with an horrible Thread.Sleep( 1 ), you should use <see cref="M:CK.Core.CriticalErrorCollector.WaitOnErrorFromBackgroundThreadsPending"/> 
            to more efficiently and securely wait for the end of this collector's job.
            </summary>
        </member>
        <member name="M:CK.Core.CriticalErrorCollector.WaitOnErrorFromBackgroundThreadsPending">
            <summary>
            Blocks the caller thread until no more event is waiting to be raised by <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/> or is being processed.
            This is the right function to use instead of pooling <see cref="P:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreadsPending"/>.
            </summary>
        </member>
        <member name="M:CK.Core.CriticalErrorCollector.ToArray">
            <summary>
            Obtains a copy of the last (up to) <see cref="P:CK.Core.CriticalErrorCollector.Capacity"/> errors from oldest to newest.
            The newest may have not been raised by <see cref="E:CK.Core.CriticalErrorCollector.OnErrorFromBackgroundThreads"/> yet.
            </summary>
            <returns>An independent array. May be empty but never null.</returns>
        </member>
        <member name="P:CK.Core.CriticalErrorCollector.NextSequenceNumber">
            <summary>
            Gets the next <see cref="F:CK.Core.CriticalErrorCollector.Error.SequenceNumber"/>.
            Getting this property makes sense only if this collector is not being solicited.
            </summary>
        </member>
        <member name="P:CK.Core.CriticalErrorCollector.DispatchQueuedWorkItemCount">
            <summary>
            Gets the number of internally created queued work items 
            since this collector exists.
            </summary>
        </member>
        <member name="P:CK.Core.CriticalErrorCollector.OptimizedDispatchQueuedWorkItemCount">
            <summary>
            Gets the number of work items that have been saved since another one 
            was ready to dispatch the events.
            This is a measure of an internal optimization that makes sense only under
            heavy loads (unit tests).
            </summary>
        </member>
        <member name="T:CK.Core.DateTimeStamp">
            <summary>
            A date and time stamp encapsulates a <see cref="F:CK.Core.DateTimeStamp.TimeUtc"/> (<see cref="T:System.DateTime"/> guaranteed to be in Utc) and a <see cref="F:CK.Core.DateTimeStamp.Uniquifier"/>.
            </summary>
        </member>
        <member name="F:CK.Core.DateTimeStamp.MinValue">
            <summary>
            Represents the smallest possible value for a DateTimeStamp object.         
            </summary>
        </member>
        <member name="F:CK.Core.DateTimeStamp.Unknown">
            <summary>
            Represents an unknown, default, DateTimeStamp object.
            This is available to have a more expressive code than <c>new DateTimeStamp()</c>.
            </summary>
        </member>
        <member name="F:CK.Core.DateTimeStamp.MaxValue">
            <summary>
            Represents the largest possible value for a DateTimeStamp object.         
            </summary>
        </member>
        <member name="F:CK.Core.DateTimeStamp.Invalid">
            <summary>
            Represents an invalid DateTimeStamp object. See <see cref="P:CK.Core.DateTimeStamp.IsInvalid"/>.
            </summary>
        </member>
        <member name="F:CK.Core.DateTimeStamp.TimeUtc">
            <summary>
            DateTime in Utc.
            </summary>
        </member>
        <member name="F:CK.Core.DateTimeStamp.Uniquifier">
            <summary>
            Uniquifier: non zero when <see cref="F:CK.Core.DateTimeStamp.TimeUtc"/> collides.
            </summary>
        </member>
        <member name="M:CK.Core.DateTimeStamp.#ctor(System.DateTime,System.Byte)">
            <summary>
            Initializes a new <see cref="T:CK.Core.DateTimeStamp"/>.
            </summary>
            <param name="timeUtc">The log time. <see cref="P:System.DateTime.Kind"/> must be <see cref="F:System.DateTimeKind.Utc"/>.</param>
            <param name="uniquifier">Optional non zero uniquifier.</param>
        </member>
        <member name="M:CK.Core.DateTimeStamp.#ctor(CK.Core.DateTimeStamp,System.DateTime,System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.DateTimeStamp"/> that is that is guaranteed to be unique and ascending (unless <paramref name="ensureGreaterThanLastOne"/> 
            is false) regarding <paramref name="lastOne"/>.
            </summary>
            <param name="lastOne">Last time stamp.</param>
            <param name="time">Time (generally current <see cref="P:System.DateTime.UtcNow"/>).</param>
            <param name="ensureGreaterThanLastOne">False to only check for time equality collision instead of guarantying ascending log time.</param>
        </member>
        <member name="M:CK.Core.DateTimeStamp.#ctor(CK.Core.DateTimeStamp,CK.Core.DateTimeStamp)">
            <summary>
            Initializes a new <see cref="T:CK.Core.DateTimeStamp"/> that is that is guaranteed to be unique and ascending regarding <paramref name="lastOne"/>.
            </summary>
            <remarks>
            The <see cref="F:CK.Core.DateTimeStamp.Uniquifier"/> is optimized if possible (this simply calls <see cref="M:CK.Core.DateTimeStamp.#ctor(CK.Core.DateTimeStamp,System.DateTime,System.Boolean)"/> with ensureGreaterThanLastOne sets to true).
            </remarks>
            <param name="lastOne">Last time stamp.</param>
            <param name="newTime">DateTimeStamp to combine.</param>
        </member>
        <member name="P:CK.Core.DateTimeStamp.IsKnown">
            <summary>
            Gets whether this <see cref="T:CK.Core.DateTimeStamp"/> is initialized.
            The default constructor of a structure can not be defined and it initializes the <see cref="F:CK.Core.DateTimeStamp.TimeUtc"/> with a zero that is <see cref="F:System.DateTime.MinValue"/>
            with a <see cref="P:System.DateTime.Kind"/> set to <see cref="F:System.DateTimeKind.Unspecified"/>.
            </summary>
        </member>
        <member name="P:CK.Core.DateTimeStamp.IsInvalid">
            <summary>
            Gets whether this <see cref="T:CK.Core.DateTimeStamp"/> is the <see cref="F:CK.Core.DateTimeStamp.Invalid"/> one.
            <see cref="F:CK.Core.DateTimeStamp.TimeUtc"/> has a <see cref="P:System.DateTime.Kind"/> set to <see cref="F:System.DateTimeKind.Local"/>.
            </summary>
        </member>
        <member name="P:CK.Core.DateTimeStamp.UtcNow">
            <summary>
            Gets the current <see cref="P:System.DateTime.UtcNow"/> as a DateTimeStamp.
            </summary>
        </member>
        <member name="M:CK.Core.DateTimeStamp.CompareTo(CK.Core.DateTimeStamp)">
            <summary>
            Compares this <see cref="T:CK.Core.DateTimeStamp"/> to another one.
            </summary>
            <param name="other">The other DateTimeStamp to compare.</param>
            <returns>Positive value when this is greater than other, 0 when they are equal, a negative value otherwise.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.Equals(CK.Core.DateTimeStamp)">
            <summary>
            Checks equality.
            </summary>
            <param name="other">Other DateTimeStamp.</param>
            <returns>True when this is equal to other.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.CompareTo(System.Object)">
            <summary>
            Compares this DateTimeStamp to another object that must also be a stamp.
            </summary>
            <param name="value">The object to compare.</param>
            <returns>Positive value when this is greater than other, 0 when they are equal, a negative value otherwise.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.Equals(System.Object)">
            <summary>
            Overridden to check equality.
            </summary>
            <param name="other">Other object.</param>
            <returns>True when this is equal to other.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.GetHashCode">
            <summary>
            Overridden to match <see cref="M:CK.Core.DateTimeStamp.Equals(CK.Core.DateTimeStamp)"/>.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="F:CK.Core.DateTimeStamp.FormatWhenUniquifier">
            <summary>
            @"{0:yyyy-MM-dd HH\hmm.ss.fffffff}({1})" is the format that will be used to format log time when the <see cref="F:CK.Core.DateTimeStamp.Uniquifier"/> is not zero.
            It is based on <see cref="F:CK.Core.FileUtil.FileNameUniqueTimeUtcFormat"/> (that is used as-is when the Uniquifier is zero) for the date time format.
            </summary>
        </member>
        <member name="M:CK.Core.DateTimeStamp.ToString">
            <summary>
            Overridden to return a string based on <see cref="F:CK.Core.DateTimeStamp.FormatWhenUniquifier"/> or <see cref="F:CK.Core.FileUtil.FileNameUniqueTimeUtcFormat"/>.
            </summary>
            <returns>A string that can be successfully matched.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.op_Equality(CK.Core.DateTimeStamp,CK.Core.DateTimeStamp)">
            <summary>
            Checks equality.
            </summary>
            <param name="t1">First stamp.</param>
            <param name="t2">Second stamp.</param>
            <returns>True when stamps are equals.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.op_Inequality(CK.Core.DateTimeStamp,CK.Core.DateTimeStamp)">
            <summary>
            Checks inequality.
            </summary>
            <param name="t1">First stamp.</param>
            <param name="t2">Second stamp.</param>
            <returns>True when stamps are different.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.op_GreaterThan(CK.Core.DateTimeStamp,CK.Core.DateTimeStamp)">
            <summary>
            Strict greater than operator.
            </summary>
            <param name="t1">First stamp.</param>
            <param name="t2">Second stamp.</param>
            <returns>True when stamps first is greater than second.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.op_GreaterThanOrEqual(CK.Core.DateTimeStamp,CK.Core.DateTimeStamp)">
            <summary>
            Large greater than operator.
            </summary>
            <param name="t1">First stamp.</param>
            <param name="t2">Second stamp.</param>
            <returns>True when stamps first is greater than or equal to second.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.op_LessThan(CK.Core.DateTimeStamp,CK.Core.DateTimeStamp)">
            <summary>
            Strict lower than operator.
            </summary>
            <param name="t1">First stamp.</param>
            <param name="t2">Second stamp.</param>
            <returns>True when stamps first is lower than second.</returns>
        </member>
        <member name="M:CK.Core.DateTimeStamp.op_LessThanOrEqual(CK.Core.DateTimeStamp,CK.Core.DateTimeStamp)">
            <summary>
            Large lower than operator.
            </summary>
            <param name="t1">First stamp.</param>
            <param name="t2">Second stamp.</param>
            <returns>True when stamps first is lower than or equal to second.</returns>
        </member>
        <member name="T:CK.Core.DateTimeStampExtension">
            <summary>
            Exposes extension methods on <see cref="T:CK.Core.DateTimeStamp"/>.
            </summary>
        </member>
        <member name="M:CK.Core.DateTimeStampExtension.MatchDateTimeStamp(CK.Text.StringMatcher,CK.Core.DateTimeStamp@)">
            <summary>
            Matches a <see cref="T:CK.Core.DateTimeStamp"/>.
            </summary>
            <param name="this">This <see cref="T:CK.Text.StringMatcher"/>.</param>
            <param name="time">Resulting time stamp on successful match; <see cref="F:CK.Core.DateTimeStamp.Unknown"/> otherwise.</param>
            <returns>True if the time stamp has been matched.</returns>
        </member>
        <member name="T:CK.Core.ServiceContainerExtension">
            <summary>
            Provides extension methods for system/component model interfaces.
            </summary>
        </member>
        <member name="M:CK.Core.ServiceContainerExtension.GetService``1(System.IServiceProvider,System.Boolean)">
            <summary>
            Strongly typed version of <see cref="M:System.IServiceProvider.GetService(System.Type)"/>.
            </summary>
            <param name="this">This service provider.</param>
            <param name="throwOnNull">True to throw an exception if the service can not be provided (otherwise null is returned).</param>
            <returns>A service object of the required type or null if not found and <paramref name="throwOnNull"/> is false.</returns>
        </member>
        <member name="M:CK.Core.ServiceContainerExtension.GetService``1(System.IServiceProvider)">
            <summary>
            Strongly typed version of <see cref="M:System.IServiceProvider.GetService(System.Type)"/> that returns null if service is not found.
            (Same behavior as <see cref="M:System.IServiceProvider.GetService(System.Type)"/>.)
            </summary>
            <param name="this">This service provider.</param>
            <returns>A service object of the required type or null if not found.</returns>
        </member>
        <member name="M:CK.Core.ServiceContainerExtension.Remove``1(CK.Core.ISimpleServiceContainer)">
            <summary>
            Type safe version to remove a registered type.
            </summary>
            <param name="this">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ServiceContainerExtension.Add``1(CK.Core.ISimpleServiceContainer,``0)">
            <summary>
            Type safe version to register a service implementation (type of the service is the type of the implementation).
            </summary>
            <param name="this">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ServiceContainerExtension.Add``1(CK.Core.ISimpleServiceContainer,``0,System.Action{``0})">
            <summary>
            Type safe version to register a service implementation (type of the service is the type of the implementation), 
            and a callback that will be called when the service is eventually removed.
            </summary>
            <param name="this">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <param name="onRemove">Action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ServiceContainerExtension.Add``1(CK.Core.ISimpleServiceContainer,System.Func{``0})">
            <summary>
            Type safe version to register a service associated to a callback.
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="this">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ServiceContainerExtension.Add``1(CK.Core.ISimpleServiceContainer,System.Func{``0},System.Action{``0})">
            <summary>
            Type safe version to register a service associated to a callback (and a callback that will be called when the service is eventually removed).
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="this">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <param name="onRemove">Action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>
            is called and a service as been successfuly obtained.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="T:CK.Core.CKReadOnlyExtension">
            <summary>
            Provides extension methods for <see cref="T:CK.Core.ICKReadOnlyCollection`1"/>, <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> and <see cref="T:CK.Core.ICKReadOnlyUniqueKeyedCollection`2"/>.
            </summary>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.GetByKey``2(CK.Core.ICKReadOnlyUniqueKeyedCollection{``0,``1},``1)">
            <summary>
            Gets the item with the associated key, forgetting the exists out parameter in <see cref="M:CK.Core.ICKReadOnlyUniqueKeyedCollection`2.GetByKey(`1,System.Boolean@)"/>.
            </summary>
            <typeparam name="T">Type of the elements in the collection.</typeparam>
            <typeparam name="TKey">Type of the key.</typeparam>
            <param name="this">Keyed collection of elements.</param>
            <param name="key">The item key.</param>
            <returns>The item that matches the key, default(T) if the key can not be found.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.ToArray``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <summary>
            Creates an array from a read only collection.
            This is a much more efficient version than the IEnumerable ToArray extension method
            since this implementation allocates one and only one array. 
            </summary>
            <typeparam name="T">Type of the array and lists elements.</typeparam>
            <param name="this">Read only collection of elements.</param>
            <returns>A new array that contains the same element as the collection.</returns>
        </member>
        <member name="M:CK.Core.CKReadOnlyExtension.IndexOf``1(System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.Boolean})">
            <summary>
            Finds the index of a first item in a <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.
            </summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="this">This list.</param>
            <param name="predicate">Predicate function.</param>
            <returns>Index of the matching item or -1.</returns>
        </member>
        <member name="T:CK.Core.CollectionExtension">
            <summary>
            Provides extension methods for collection &amp; list interfaces.
            </summary>
        </member>
        <member name="M:CK.Core.CollectionExtension.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds multiple items to a collection.
            </summary>
            <typeparam name="T">Collection items' type.</typeparam>
            <param name="this">This collection.</param>
            <param name="items">Multiple items to add. Can not be null.</param>
        </member>
        <member name="M:CK.Core.CollectionExtension.AddRangeArray``1(System.Collections.Generic.ICollection{``0},``0[])">
            <summary>
            Adds multiple items to a collection.
            </summary>
            <typeparam name="T">Collection items' type.</typeparam>
            <param name="this">This collection.</param>
            <param name="items">Items to add.</param>
        </member>
        <member name="M:CK.Core.CollectionExtension.RemoveWhereAndReturnsRemoved``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
            <summary>
            Simple helper that removes elements in a <see cref="T:System.Collections.Generic.IList`1"/> and returns them as an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            Makes the transfer of items from one list to another easy when combined with <see cref="M:CK.Core.CollectionExtension.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})"/>.
            The returned enumerable MUST be consumed to actually remove the items from the list (this is what AddRange do).
            Calling <see cref="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})">IEnumerable&lt;T&gt;.Count()</see> for instance resolves the enumeration.
            </summary>
            <typeparam name="T">The type of the elements in the list.</typeparam>
            <param name="this">This list.</param>
            <param name="removeCondition">Predicate that must return true for items that must be removed from this list.</param>
            <returns>Removed items (can be added into another one).</returns>
        </member>
        <member name="F:CK.Core.CollectionExtension.ItemArrayChangedEventArgs">
            <summary>
            Immutable reusable PropertyChangedEventArgs for "Item[]".
            </summary>
        </member>
        <member name="F:CK.Core.CollectionExtension.CountChangedEventArgs">
            <summary>
            Immutable reusable PropertyChangedEventArgs for "Count".
            </summary>
        </member>
        <member name="M:CK.Core.CollectionExtension.AsReadOnlyCollection``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns this collection if the implementation supports <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> 
            or a <see cref="T:CK.Core.CKReadOnlyCollectionOnICollection`1"/> adapter instance.
            </summary>
            <typeparam name="T">The type of the collection items.</typeparam>
            <param name="this">This collection.</param>
            <returns>This collection or an adapter.</returns>
        </member>
        <member name="T:CK.Core.DictionaryExtension">
            <summary>
            Provides extension methods for <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:CK.Core.DictionaryExtension.GetValueWithDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Gets the value associated with the specified key if it exists otherwise returns the <paramref name="defaultValue"/>.
            </summary>
            <param name="this">This generic IDictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">Default value to use if the key does not exist.</param>
            <returns>
            The value associated with the specified key, if the key is found; otherwise, the <paramref name="defaultValue"/>. 
            </returns>
        </member>
        <member name="M:CK.Core.DictionaryExtension.GetValueWithDefaultFunc``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            Gets the value associated with the specified key if it exists otherwise calls the <paramref name="defaultValue"/> function.
            </summary>
            <param name="this">This generic IDictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">A delegate that will be called if the key does not exist.</param>
            <returns>
            The value associated with the specified key, if the key is found; otherwise, the result 
            of the <paramref name="defaultValue"/> delegate.
            </returns>
        </member>
        <member name="M:CK.Core.DictionaryExtension.GetOrSet``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            Gets the value associated with the specified key if it exists otherwise calls the <paramref name="createValue"/> function
            and adds the newly obtained value into the dictionary.
            </summary>
            <param name="this">This generic IDictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="createValue">A delegate that will be called if the key does not exist.</param>
            <returns>
            The value associated with the specified key, if the key is found; otherwise, the result 
            of the <paramref name="createValue"/> delegate (this result has been added to the dictionary).
            </returns>
        </member>
        <member name="M:CK.Core.DictionaryExtension.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Adds the content of a dictionary to this <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the dictionary.</typeparam>
            <param name="this">This generic IDictionary.</param>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Collections.Generic.KeyValuePair`2"/> from which content will be copied.</param>
        </member>
        <member name="T:CK.Core.EnumerableExtension">
            <summary>
            Provides extension methods for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedStrict``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks whether the enumerable is in strict (no duplicates) ascending order (uses the <see cref="P:System.Collections.Generic.Comparer`1.Default"/> Compare method).
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="this">This enumerable.</param>
            <returns>True if the enumerable is empty or is in strict ascending order.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedLarge``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks whether the enumerable is in large (duplicates allowed) ascending order (uses the <see cref="P:System.Collections.Generic.Comparer`1.Default"/> Compare method).
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="this">This enumerable.</param>
            <returns>True if the enumerable is empty or is in large ascending order.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedStrict``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Checks whether the enumerable is in strict (no duplicates) ascending order based on a comparison function.
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="this">This enumerable.</param>
            <param name="comparison">The delegate used to compare elements.</param>
            <returns>True if the enumerable is empty or is in strict ascending order.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedLarge``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Checks whether the enumerable is in large (duplicates allowed) ascending order based on a comparison function.
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="this">This enumerable.</param>
            <param name="comparison">The delegate used to compare elements.</param>
            <returns>True if the enumerable is empty or is in large ascending order.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns the maximal element of the given sequence based on a projection of comparable keys. 
            The sequence MUST NOT be empty otherwise an <see cref="T:System.InvalidOperationException"/> is thrown.
            </summary>
            <remarks>
            If more than one element has the maximal projected value, the first
            one encountered will be returned. This operator uses immediate execution, but
            only buffers a single result (the current maximal element).
            </remarks>
            <typeparam name="TSource">Type of the source sequence.</typeparam>
            <typeparam name="TKey">Type of the projected element. Must be <see cref="T:System.IComparable`1"/>.</typeparam>
            <param name="this">Source sequence.</param>
            <param name="selector">Selector to use to pick the results to compare</param>
            <returns>The maximal element, according to the projection.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="this"/> or <paramref name="selector"/> is null</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="this"/> is empty</exception>       
        </member>
        <member name="M:CK.Core.EnumerableExtension.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Comparison{``1})">
            <summary>
            Returns the maximal element of the given sequence based on
            a projection and a <see cref="T:System.Comparison`1"/> (that defaults to <c>Comparer&lt;TKey&gt;.Default.Compare</c>.
            The sequence MUST NOT be empty otherwise an <see cref="T:System.InvalidOperationException"/> is thrown.
            </summary>
            <remarks>
            If more than one element has the maximal projected value, the first
            one encountered will be returned. This operator uses immediate execution, but
            only buffers a single result (the current maximal element).
            </remarks>
            <typeparam name="TSource">Type of the source sequence.</typeparam>
            <typeparam name="TKey">Type of the projected element.</typeparam>
            <param name="this">Source sequence.</param>
            <param name="selector">Selector to use to pick the results to compare.</param>
            <param name="comparison">Comparison function  to use to compare projected values. When null, <c>Comparer&lt;TKey&gt;.Default.Compare</c> is used.</param>
            <returns>The maximal element, according to the projection.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="this"/> or <paramref name="selector"/> is null</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="this"/> is empty</exception>       
        </member>
        <member name="M:CK.Core.EnumerableExtension.IndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Gets the first index in the enumerable where the predicate evaluates to true.
            Returns -1 when not found.
            </summary>
            <typeparam name="TSource">Type of source sequence.</typeparam>
            <param name="this">Source sequence.</param>
            <param name="predicate">Predicate function.</param>
            <returns>Index where predicate is true. -1 if not found.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Gets the first index in the enumerable where the predicate evaluates to true, the index of the element is available to the predicate.
            Returns -1 when not found.
            </summary>
            <typeparam name="TSource">Type of source sequence.</typeparam>
            <param name="this">Source sequence.</param>
            <param name="predicate">Predicate function that accepts the element and its index.</param>
            <returns>Index where predicate is true, or -1 if not found.</returns>
        </member>
        <member name="T:CK.Core.EnumerableExtension.EAppend`1">
            <summary>
            Internal implementation of Append extension method.
            </summary>
            <typeparam name="T">Type of source sequence.</typeparam>
        </member>
        <member name="M:CK.Core.EnumerableExtension.Append``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEnumerable`1"/> that appends one item to an existing enumerable.
            </summary>
            <typeparam name="TSource">Type of source sequence.</typeparam>
            <param name="this">Source sequence.</param>
            <param name="item">Item to append.</param>
            <returns>An enumerable that appends the item to trhe sequence.</returns>
        </member>
        <member name="T:CK.Core.XmlExtension">
            <summary>
            Extension methods for <see cref="T:System.Xml.XmlReader"/> and <see cref="T:System.Xml.Linq.XElement"/>
            classes.
            </summary>
        </member>
        <member name="M:CK.Core.XmlExtension.GetLineColumnString(System.Xml.IXmlLineInfo,System.String,System.String)">
            <summary>
            Gets line and column information (if it exists) as a string from any <see cref="T:System.Xml.Linq.XObject"/> (such as <see cref="T:System.Xml.Linq.XAttribute"/> or <see cref="T:System.Xml.Linq.XElement"/>).
            </summary>
            <param name="this">This <see cref="T:System.Xml.IXmlLineInfo"/>.</param>
            <param name="format">Default format is "- @Line,Column".</param>
            <param name="noLineInformation">Defaults to a null string when <see cref="M:System.Xml.IXmlLineInfo.HasLineInfo"/> is false.</param>
            <returns>A string based on <paramref name="format"/> or <paramref name="noLineInformation"/>.</returns>
        </member>
        <member name="M:CK.Core.XmlExtension.AttributeRequired(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Gets the attribute by its name or throws an <see cref="T:System.Xml.XmlException"/> if it does not exist.
            </summary>
            <param name="this">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.AttributeEnum``1(System.Xml.Linq.XElement,System.Xml.Linq.XName,``0)">
            <summary>
            Gets an enum value.
            </summary>
            <typeparam name="T">Type of the enum. There is no way (in c#) to constraint the type to Enum - nor to Delegate, this is why 
            the constraint restricts only the type to be a value type.</typeparam>
            <param name="this">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist or can not be parsed.</param>
            <returns>The parsed value or the default value.</returns>
        </member>
        <member name="T:CK.Core.FIFOBuffer`1">
            <summary>
            Simple implementation of a fixed size FIFO stack based on a circular buffer. 
            The .Net <see cref="T:System.Collections.Generic.Queue`1"/>'s size increase as needed whereas this FIFO automatically loses the oldest items.
            Note that when <typeparamref name="T"/> is a reference type, null can be pushed and pop.
            This can easily be used as a LIFO stack thanks to <see cref="M:CK.Core.FIFOBuffer`1.PopLast"/> and <see cref="M:CK.Core.FIFOBuffer`1.PeekLast"/> methods.
            </summary>
            <typeparam name="T">Type of the items.</typeparam>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.#ctor(System.Int32)">
            <summary>
            Initializes a new <see cref="T:CK.Core.FIFOBuffer`1"/> with an initial capacity.
            </summary>
            <param name="capacity">Initial capacity (can be 0).</param>
        </member>
        <member name="P:CK.Core.FIFOBuffer`1.Capacity">
            <summary>
            Gets or sets the capacity (internal buffer will be resized).
            </summary>
        </member>
        <member name="P:CK.Core.FIFOBuffer`1.Count">
            <summary>
            Gets the actual count of element: it is necessary less than or equal to <see cref="P:CK.Core.FIFOBuffer`1.Capacity"/>.
            </summary>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Truncate(System.Int32)">
            <summary>
            Truncates the queue: only the <paramref name="newCount"/> newest items are kept.
            Pops as many old items (the ones that have been pushed first) in order for <see cref="P:CK.Core.FIFOBuffer`1.Count"/> to be equal to newCount.
            </summary>
            <param name="newCount">The final number of items. If it is greater or equal to the current <see cref="P:CK.Core.FIFOBuffer`1.Count"/>, nothing is done.</param>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Contains(System.Object)">
            <summary>
            Tests whether the buffer actually contains the given object.
            </summary>
            <param name="item">Object to test.</param>
            <returns>True if the object exists.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.IndexOf(System.Object)">
            <summary>
            Gets the index of the given object.
            </summary>
            <param name="item">Object to find.</param>
            <returns>The index of the object or -1 if not found.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.IndexOf(`0)">
            <summary>
            Gets the index of the given object.
            </summary>
            <param name="item">Object to find.</param>
            <returns>
            The index of the object or the bitwise complement of <see cref="P:CK.Core.FIFOBuffer`1.Count"/> if not 
            found (that is a negative value, see <see cref="M:CK.Core.ICKReadOnlyList`1.IndexOf(System.Object)"/>).
            </returns>
        </member>
        <member name="P:CK.Core.FIFOBuffer`1.Item(System.Int32)">
            <summary>
            Gets the element by index. Index 0 is the oldest item, the one returned by <see cref="M:CK.Core.FIFOBuffer`1.Peek"/> and <see cref="M:CK.Core.FIFOBuffer`1.Pop"/>.
            </summary>
            <param name="index">Index must be positive and less than <see cref="P:CK.Core.FIFOBuffer`1.Count"/>.</param>
            <returns>The indexed element.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element by index. Index 0 is the oldest item, the one returned by <see cref="M:CK.Core.FIFOBuffer`1.Peek"/> and <see cref="M:CK.Core.FIFOBuffer`1.Pop"/>.
            </summary>
            <param name="index">Index must be positive and less than <see cref="P:CK.Core.FIFOBuffer`1.Count"/>.</param>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Clear">
            <summary>
            Clears the internal buffer.
            </summary>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Push(`0)">
            <summary>
            Adds an item.
            </summary>
            <param name="item">Item to push.</param>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Pop">
            <summary>
            Gets and removes the first item (the one that has been <see cref="M:CK.Core.FIFOBuffer`1.Push(`0)"/>ed first).
            <see cref="P:CK.Core.FIFOBuffer`1.Count"/> must be greater than 0 otherwise an exception is thrown.
            </summary>
            <returns>The first (oldest) item.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.PopLast">
            <summary>
            Gets and removes the last item (the last one that has been <see cref="M:CK.Core.FIFOBuffer`1.Push(`0)"/>ed).
            <see cref="P:CK.Core.FIFOBuffer`1.Count"/> must be greater than 0 otherwise an exception is thrown.
            </summary>
            <returns>The last (newest) item.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Peek">
            <summary>
            Gets the first item (the one that has been <see cref="M:CK.Core.FIFOBuffer`1.Push(`0)"/>ed first).
            <see cref="P:CK.Core.FIFOBuffer`1.Count"/> must be greater than 0 otherwise an exception is thrown.
            </summary>
            <returns>The first (oldest) item.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.PeekLast">
            <summary>
            Gets the last item (the last one that has been <see cref="M:CK.Core.FIFOBuffer`1.Push(`0)"/>).
            <see cref="P:CK.Core.FIFOBuffer`1.Count"/> must be greater than 0 otherwise an exception is thrown.
            </summary>
            <returns>The last (newest) item.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.CopyTo(`0[])">
            <summary>
            Copies as much possible items into the given array. Order is from oldest to newest.
            If the target array is too small to contain <see cref="P:CK.Core.FIFOBuffer`1.Count"/> items, the newest ones
            are copied (the oldest, the ones that will <see cref="M:CK.Core.FIFOBuffer`1.Pop"/> first, are skipped).
            </summary>
            <param name="array">Array that will contain the items.</param>
            <returns>Number of items copied.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies as much possible items into the given array. Order is from oldest to newest. 
            If the target array is too small to contain <see cref="P:CK.Core.FIFOBuffer`1.Count"/> items, the newest ones
            are copied (the oldest, the ones that will <see cref="M:CK.Core.FIFOBuffer`1.Pop"/> first, are skipped).
            </summary>
            <param name="array">Array that will contain the items.</param>
            <param name="arrayIndex">Index in <paramref name="array"/> where copy must start.</param>
            <returns>Number of items copied.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.CopyTo(`0[],System.Int32,System.Int32)">
            <summary>
            Copies as much possible items into the given array. Order is from oldest to newest.
            If <paramref name="count"/> is less than <see cref="P:CK.Core.FIFOBuffer`1.Count"/>, the newest ones
            are copied (the oldest, the ones that will <see cref="M:CK.Core.FIFOBuffer`1.Pop"/> first, are skipped).
            </summary>
            <param name="array">Array that will contain the items.</param>
            <param name="arrayIndex">Index in <paramref name="array"/> where copy must start.</param>
            <param name="count">Number of items to copy.</param>
            <returns>Number of items copied.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.GetEnumerator">
            <summary>
            Gets the enumerator (from oldest to newest item).
            </summary>
            <returns>An enumerator.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.ToArray">
            <summary>
            Creates an array that contains <see cref="P:CK.Core.FIFOBuffer`1.Count"/> items from oldest to newest.
            </summary>
            <returns>An array with the contained items. Never null.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Non-generic version of <see cref="M:CK.Core.FIFOBuffer`1.GetEnumerator"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.ToString">
            <summary>
            Overridden to display the current count of items and capacity for this buffer.
            </summary>
            <returns>Current count and capacity.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor.
            </summary>
            <param name="info">Serialization information.</param>
            <param name="context">Serialization context.</param>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization.
            </summary>
            <param name="info">Serialization information.</param>
            <param name="context">Serialization context.</param>
        </member>
        <member name="T:CK.Core.FileUtil">
            <summary>
            Helper functions related to file system.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.InexistingFile">
            <summary>
            Combination of <see cref="T:System.IO.FileAttributes"/> that can not exist: it can be used to 
            tag non existing files among other existing (i.e. valid) file attributes.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.GzipFileHeader">
            <summary>
            The file header for gzipped files.
            </summary>
        </member>
        <member name="M:CK.Core.FileUtil.NormalizePathSeparator(System.String,System.Boolean)">
            <summary>
            Canonicalizes the path: all '/' and '\' are mapped to <see cref="F:System.IO.Path.DirectorySeparatorChar"/> 
            (and <see cref="F:System.IO.Path.AltDirectorySeparatorChar"/> will also be transformed).
            </summary>
            <param name="path">The path to standardize (must be not be null). It is trimmed and if the path is empty, the empty string is returned.</param>
            <param name="ensureTrailingBackslash">
            Ensures that the normalized path will end with a <see cref="F:System.IO.Path.DirectorySeparatorChar"/>.
            It should be true for path to directories because we consider that a directory path SHOULD end with 
            the slash as often as possible.
            When <paramref name="path"/> is empty, this is not applied to preserve the fact that the string is empty.
            </param>
            <returns>
            A standardized path, whatever the actual <c>Path.DirectorySeparatorChar</c> is
            on the current platform.
            </returns>
        </member>
        <member name="F:CK.Core.FileUtil.DirectorySeparatorString">
            <summary>
            Gets the <see cref="F:System.IO.Path.DirectorySeparatorChar"/> as a string.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.AltDirectorySeparatorString">
            <summary>
            Gets the <see cref="F:System.IO.Path.AltDirectorySeparatorChar"/> as a string.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.FileNameUniqueTimeUtcFormat">
            <summary>
            A display format for <see cref="T:System.DateTime"/> that supports round-trips, is readable and can be used in path 
            or url (the DateTime should be in UTC since <see cref="P:System.DateTime.Kind"/> is ignored).
            Use <see cref="M:CK.Core.FileUtil.MatchFileNameUniqueTimeUtcFormat(CK.Text.StringMatcher,System.DateTime@)"/> or <see cref="M:CK.Core.FileUtil.TryParseFileNameUniqueTimeUtcFormat(System.String,System.DateTime@,System.Boolean)"/> to parse it (it uses the correct <see cref="T:System.Globalization.DateTimeStyles"/>).
            It is: @"yyyy-MM-dd HH\hmm.ss.fffffff"
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.MissingFileLastWriteTimeUtc">
            <summary>
            The time returned by <see cref="M:System.IO.File.GetLastWriteTimeUtc(System.String)"/> when the file does not exist.
            From MSDN: If the file described in the path parameter does not exist, this method returns 12:00 midnight, January 1, 1601 A.D. (C.E.) Coordinated Universal Time (UTC).
            </summary>
        </member>
        <member name="M:CK.Core.FileUtil.MatchFileNameUniqueTimeUtcFormat(CK.Text.StringMatcher,System.DateTime@)">
            <summary>
            Matches a DateTime in the <see cref="F:CK.Core.FileUtil.FileNameUniqueTimeUtcFormat"/> format.
            </summary>
            <param name="this">This <see cref="T:CK.Text.StringMatcher"/>.</param>
            <param name="time">Result time on success; otherwise <see cref="F:CK.Core.Util.UtcMinValue"/>.</param>
            <returns>True if the time has been matched.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.TryParseFileNameUniqueTimeUtcFormat(System.String,System.DateTime@,System.Boolean)">
            <summary>
            Tries to parse a string formatted with the <see cref="F:CK.Core.FileUtil.FileNameUniqueTimeUtcFormat"/>.
            The string must contain only the time unless <paramref name="allowSuffix"/> is true.
            </summary>
            <param name="s">The string to parse.</param>
            <param name="time">Result time on success.</param>
            <param name="allowSuffix">True to accept a string that starts with the time and contains more text.</param>
            <returns>True if the string has been successfully parsed.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.IndexOfInvalidPathChars(System.String)">
            <summary>
            Finds the first character index of any characters that are invalid in a path.
            This method (and <see cref="M:CK.Core.FileUtil.IndexOfInvalidFileNameChars(System.String)"/>) avoid the allocation of 
            the array each time <see cref="M:System.IO.Path.GetInvalidPathChars"/> is called.
            </summary>
            <param name="path">Path to check. Can not be null.</param>
            <returns>A negative value if not found.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.IndexOfInvalidFileNameChars(System.String)">
            <summary>
            Finds the first character index of any characters that are invalid in a file name.
            This method (and <see cref="M:CK.Core.FileUtil.IndexOfInvalidPathChars(System.String)"/>) avoid the allocation of 
            the array each time <see cref="M:System.IO.Path.GetInvalidFileNameChars"/> is called.
            </summary>
            <param name="path">Path to check. Can not be null.</param>
            <returns>A negative value if not found.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.WriteUniqueTimedFile(System.String,System.String,System.DateTime,System.Byte[],System.Boolean,System.Int32)">
            <summary>
            Creates a new necessarily unique file and writes bytes content in a directory that must exist.
            The file name is based on a <see cref="T:System.DateTime"/>, with an eventual uniquifier if a file already exists with the same name.
            </summary>
            <param name="pathPrefix">The path prefix. Must not be null. Must be a valid path and may ends with a prefix for the file name itself.</param>
            <param name="fileSuffix">Suffix for the file name. Must not be null. Typically an extension (like ".txt").</param>
            <param name="time">The time that will be used to create the file name. It should be an UTC time.</param>
            <param name="content">The bytes to write. Can be null or empty if the file must only be created.</param>
            <param name="withUTF8Bom">True to write the UTF8 Byte Order Mask (the preamble).</param>
            <param name="maxTryBeforeGuid">Maximum value for short hexa uniquifier before using a base 64 guid suffix. Must between 0 and 15 (included).</param>
            <returns>The full path name of the created file.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.CreateAndOpenUniqueTimedFile(System.String,System.String,System.DateTime,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Int32)">
            <summary>
            Creates and opens a new necessarily unique file in a directory that must exist.
            The file name is based on a <see cref="T:System.DateTime"/>, with an eventual uniquifier if a file already exists with the same name.
            You can use <see cref="P:System.IO.FileStream.Name"/> to obtain the file name.
            </summary>
            <param name="pathPrefix">The path prefix. Must not be null. Must be a valid path and may ends with a prefix for the file name itself.</param>
            <param name="fileSuffix">Suffix for the file name. Must not be null. Typically an extension (like ".txt").</param>
            <param name="time">The time that will be used to create the file name. It must be an UTC time.</param>
            <param name="access">
            A constant that determines how the file can be accessed by the FileStream object. 
            It can only be <see cref="F:System.IO.FileAccess.Write"/> or <see cref="F:System.IO.FileAccess.ReadWrite"/> (when set to <see cref="F:System.IO.FileAccess.Read"/> a <see cref="T:System.ArgumentException"/> is thrown).
            This sets the CanRead and CanWrite properties of the FileStream object. 
            CanSeek is true if path specifies a disk file.
            </param>
            <param name="share">
            A constant that determines how the file will be shared by processes.
            </param>
            <param name="bufferSize">
            A positive Int32 value greater than 0 indicating the buffer size. For bufferSize values between one and eight, the actual buffer size is set to eight bytes.
            </param>
            <param name="options">Specifies additional file options.</param>
            <param name="maxTryBeforeGuid">
            Maximum value for short hexadecimal uniquifier before using a base 64 guid suffix. Must greater than 0.</param>
            <returns>An opened <see cref="T:System.IO.FileStream"/>.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.MoveToUniqueTimedFile(System.String,System.String,System.String,System.DateTime,System.Int32)">
            <summary>
            Moves (renames) a file to a necessarily unique named file.
            The file name is based on a <see cref="T:System.DateTime"/>, with an eventual uniquifier if a file already exists with the same name.
            </summary>
            <param name="sourceFilePath">Path of the file to move.</param>
            <param name="pathPrefix">The path prefix. Must not be null. Must be a valid path and may ends with a prefix for the file name itself.</param>
            <param name="fileSuffix">Suffix for the file name. Must not be null. Typically an extension (like ".txt").</param>
            <param name="time">The time that will be used to create the file name. It must be an UTC time.</param>
            <param name="maxTryBeforeGuid">
            Maximum value for short hexadecimal uniquifier before using a base 64 guid suffix. Must greater than 0.
            </param>
            <returns>An opened <see cref="T:System.IO.FileStream"/>.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.EnsureUniqueTimedFile(System.String,System.String,System.DateTime,System.Int32)">
            <summary>
            Gets a path to a necessarily unique named file.
            The file name is based on a <see cref="T:System.DateTime"/>, with an eventual uniquifier if a file already exists with the same name.
            </summary>
            <param name="pathPrefix">The path prefix. Must not be null. Must be a valid path and may ends with a prefix for the file name itself.</param>
            <param name="fileSuffix">Suffix for the file name. Must not be null. Typically an extension (like ".txt").</param>
            <param name="time">The time that will be used to create the file name. It must be an UTC time.</param>
            <param name="maxTryBeforeGuid">
            Maximum value for short hexadecimal uniquifier before using a base 64 guid suffix. Must greater than 0.
            </param>
            <returns>A string to a necessarily unique named file path.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.FormatTimedUniqueFilePart(System.DateTime)">
            <summary>
            Formats a string that is file name compatible from the given time and a <see cref="M:System.Guid.NewGuid"/>
            where time uses <see cref="F:CK.Core.FileUtil.FileNameUniqueTimeUtcFormat"/> and the new Guid is 
            encoded with http://en.wikipedia.org/wiki/Base64#URL_applications.
            </summary>
            <param name="time">The date time to use.</param>
            <returns>A string with the time and a new guid in a file system compatible format.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.CopyDirectory(System.IO.DirectoryInfo,System.IO.DirectoryInfo,System.Boolean,System.Boolean,System.Func{System.IO.FileInfo,System.Boolean},System.Func{System.IO.DirectoryInfo,System.Boolean})">
            <summary>
            Recursively copy a directory, creates it if it does not already exists. 
            Throws an IOException, if a same file exists in the target directory.
            </summary>
            <param name="src">The source directory.</param>
            <param name="target">The target directory.</param>
            <param name="withHiddenFiles">False to skip hidden files.</param>
            <param name="withHiddenFolders">False to skip hidden folders.</param>
            <param name="fileFilter">Optional predicate for directories.</param>
            <param name="dirFilter">Optional predicate for files.</param>
        </member>
        <member name="M:CK.Core.FileUtil.CheckForWriteAccess(System.String,System.Int32)">
            <summary>
            Waits for a file to be writable or does not exist (if it does not exist, it can be created!).
            The file is opened and close.
            Waits the number of <paramref name="nbMaxMilliSecond"/> before leaving and returning false: when 0 (the default),
            there is no wai. A nbMaxMilliSecond below 20 ~ 30 milliseconds is not accurate: even with nbMaxMilliSecond = 1
            this method will return true if the file becomes writable during the next 10 or 20 milliseconds.
            </summary>
            <param name="path">The path of the file to write to.</param>
            <param name="nbMaxMilliSecond">Maximum number of milliseconds to wait before returning false.</param>
            <returns>True if the file has been correctly opened (and closed) in write mode.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.CompressFileToGzipFileAsync(System.String,System.String,System.Threading.CancellationToken,System.Boolean,System.IO.Compression.CompressionLevel,System.Int32)">
            <summary>
            Compresses a file to another file asynchronously, using GZip at the given compression level.
            </summary>
            <param name="sourceFilePath">The source file path.</param>
            <param name="destinationPath">The destination path. If it doesn't exist, it will be created. If it exists, it will be replaced.</param>
            <param name="cancellationToken">Optional cancellation token for the task.</param>
            <param name="deleteSourceFileOnSuccess">If set to <c>true</c>, will delete source file if no error occurred during compression.</param>
            <param name="level">Compression level to use.</param>
            <param name="bufferSize">Size of the buffer, in bytes.</param>
        </member>
        <member name="M:CK.Core.FileUtil.CompressFileToGzipFile(System.String,System.String,System.Boolean,System.IO.Compression.CompressionLevel,System.Int32)">
            <summary>
            Compresses a file to another file, using GZip at the given compression level.
            </summary>
            <param name="sourceFilePath">The source file path.</param>
            <param name="destinationPath">The destination path. If it doesn't exist, it will be created. If it exists, it will be replaced.</param>
            <param name="deleteSourceFileOnSuccess">if set to <c>true</c>, will delete source file if no errors occured during compression.</param>
            <param name="level">Compression level to use.</param>
            <param name="bufferSize">Size of the buffer, in bytes.</param>
        </member>
        <member name="T:CK.Core.GrantLevel">
            <summary>
            Standard grant level: this is a simple (but often enough) way to secure a resource.
            Among the different levels, depending on the actual resource, some (or most) of them 
            are useless and can be ignored.
            But for some kind of resources all of them make sense: a "service object" (a kind of executable process) for instance can
            benefits of all these levels.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.Blind">
            <summary>
            Actor doesn't even know that object exists.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.User">
            <summary>
            Actor can see the object names and may use services provided by the object 
            but cannot see the object itself.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.Viewer">
            <summary>
            Actor can view the object but cannot interact with it.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.Contributor">
            <summary>
            Actor can contribute to the object but cannot modifiy the object itself.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.Editor">
            <summary>
            Actor can edit the standard properties of the object. He may not be able to 
            change more sensitive aspects such as the different names of the object.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.SuperEditor">
            <summary>
            Actor can edit the object, its names and any property, but can not change
            the security settings.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.SafeAdministrator">
            <summary>
            Actor can edit all properties of the object and can 
            change the security settings by choosing an acl among defined security
            contexts. The actor can not destroy the object.
            </summary>
        </member>
        <member name="F:CK.Core.GrantLevel.Administrator">
            <summary>
            Actor has full control on the object including its destruction. It may create 
            and configure an independent Acl for the object.
            </summary>
        </member>
        <member name="T:CK.Core.ICKReadOnlyCollection`1">
            <summary>
            Represents a generic read only collections of objects with a contravariant <see cref="M:CK.Core.ICKReadOnlyCollection`1.Contains(System.Object)"/> method.
            This enables collection implementing this interface to support better lookup complexity than O(n) if possible. 
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
        </member>
        <member name="M:CK.Core.ICKReadOnlyCollection`1.Contains(System.Object)">
            <summary>
            Determines whether collection contains a specific value.
            </summary>
            <param name="item">The object to find in the collecion.</param>
            <returns>True if item is found in the collection; otherwise, false.</returns>
        </member>
        <member name="T:CK.Core.ICKReadOnlyList`1">
            <summary>
            Represents a read only collection of objects that can be individually accessed by index.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="M:CK.Core.ICKReadOnlyList`1.IndexOf(System.Object)">
            <summary>
            Determines the index of a specific item in the list.
            </summary>
            <param name="item">The object to locate in the list.</param>
            <returns>
            A positive index of the item in this list, if found, a negative index otherwise.
            If this list is sorted, this must work exactly like <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: if the item is not found and could be added, the result 
            is a negative number which is the bitwise complement of the index at which the new item should be inserted.
            To handle the case where the item can NOT be inserted and to be consistent with the positive/negative index semantics, the <see cref="F:System.Int32.MinValue"/>
            must be returned. See remarks.
            </returns>
            <remarks>
            <para>
            The fact that <see cref="F:System.Int32.MinValue"/> is used to indicate an "impossible index" enables this covariant list to gracefully handle 
            the case where the item's type is more general that the actual type list.
            </para>
            <para>
            Similarly, if the implementation is associated to any kind of filters, returning <see cref="F:System.Int32.MinValue"/> instead of any other negative value
            indicates to the caller that the item does not appear in the list, but more than that, that it CAN NOT appear.
            </para>
            <para>
            Note that an implementation can perfectly ignore these guidelines and returns -1 (typically) for any unexisting items: it is not an obligation
            to challenge any possible filters or constraints inside this IndexOf method.
            </para>
            <para>
            On the other hand, if this method returns <see cref="F:System.Int32.MinValue"/> then it MUST mean that the item can NOT appear in this list.
            </para>
            </remarks>
        </member>
        <member name="T:CK.Core.ICKReadOnlyMultiKeyedCollection`2">
            <summary>
            Represents a generic read only keyed collections of covariant items with
            a contravariant key that can support duplicate items.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
            <typeparam name="TKey">The type of the key associated to the elements.</typeparam>
        </member>
        <member name="P:CK.Core.ICKReadOnlyMultiKeyedCollection`2.AllowDuplicates">
            <summary>
            Gets whether this collection supports duplicates.
            </summary>
        </member>
        <member name="M:CK.Core.ICKReadOnlyMultiKeyedCollection`2.KeyCount(`1)">
            <summary>
            Gets the number of items in this keyed collection that are associated to the
            given key value.
            </summary>
            <param name="key">The key to find.</param>
            <returns>Number of items with the <paramref name="key"/>.</returns>
        </member>
        <member name="M:CK.Core.ICKReadOnlyMultiKeyedCollection`2.GetAllByKey(`1)">
            <summary>
            Gets an independant collection of the items that 
            are associated to the given key value.
            </summary>
            <param name="key">The key to find.</param>
            <returns>An independant collection of <typeparamref name="T"/>.</returns>
        </member>
        <member name="T:CK.Core.ICKReadOnlyUniqueKeyedCollection`2">
            <summary>
            Represents a generic read only keyed collections of covariant items with
            a contravariant key. This interface can be supported by collections that 
            support duplicated items.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
            <typeparam name="TKey">The type of the key associated to the elements.</typeparam>
        </member>
        <member name="M:CK.Core.ICKReadOnlyUniqueKeyedCollection`2.Contains(`1)">
            <summary>
            Checks whether any item in this keyed collection is associated to the
            given key value.
            </summary>
            <param name="key">The key to find.</param>
            <returns>True if the key exists, false otherwise.</returns>
        </member>
        <member name="M:CK.Core.ICKReadOnlyUniqueKeyedCollection`2.GetByKey(`1,System.Boolean@)">
            <summary>
            Gets the item with the associated key.
            When duplicated item exists, any item with the given key can be returned.
            </summary>
            <param name="key">The item key.</param>
            <param name="exists">True if the key has been found, false otherwise (see remarks).</param>
            <returns>The item that matches the key, default(T) if the key can not be found.</returns>
            <remarks>
            Due to current CLI limitation (out parameters are actually ref parameters), it is not possible 
            to define a method with an ( out T ) parameter where T is covariant: we can not define 
            the standard TryGetValue method but this "opposite" form.
            </remarks>
        </member>
        <member name="T:CK.Core.ICKWritableCollection`1">
            <summary>
            Contravariant interface for a collection that allows to <see cref="M:CK.Core.ICKWritableCollection`1.Clear"/> and <see cref="M:CK.Core.ICKWritableCollection`1.Remove(`0)"/>
            element.
            </summary>
            <typeparam name="T">Base type for the elements of the collection.</typeparam>
        </member>
        <member name="M:CK.Core.ICKWritableCollection`1.Clear">
            <summary>
            Clears the collection.
            </summary>
        </member>
        <member name="M:CK.Core.ICKWritableCollection`1.Remove(`0)">
            <summary>
            Removes the element if it exists.
            </summary>
            <param name="e">Element to remove.</param>
            <returns>True if the element has been removed, false otherwise.</returns>
        </member>
        <member name="T:CK.Core.ICKWritableCollector`1">
            <summary>
            Contravariant interface for a collector: one can only add elements to a collector and know how much elements
            there are (Note that if you do not need the <see cref="P:CK.Core.ICKWritableCollector`1.Count"/>, you should use a simple Fun&lt;T,bool&gt;).
            </summary>
            <typeparam name="T">Base type for the elements of the collector.</typeparam>
        </member>
        <member name="P:CK.Core.ICKWritableCollector`1.Count">
            <summary>
            Gets the count of elements in the collection.
            </summary>
        </member>
        <member name="M:CK.Core.ICKWritableCollector`1.Add(`0)">
            <summary>
            Adds an element to the collection. The exact behavior of this operation
            depends on the concrete implementation (duplicates, filters, etc.).
            </summary>
            <param name="e">Element to add.</param>
            <returns>True if the element has been added, false otherwise.</returns>
        </member>
        <member name="T:CK.Core.IMergeable">
            <summary>
            Simple interface to support merging of information from external objects.
            </summary>
        </member>
        <member name="M:CK.Core.IMergeable.Merge(System.Object,System.IServiceProvider)">
            <summary>
            Attempts to merge this object with the given one.
            This method should not raise any exception. Instead, false should be returned. 
            If an exception is raised, callers should handle the exception and behaves as if the method returned false.
            </summary>
            <param name="source">Source object to merge into this one.</param>
            <param name="services">Optional services (can be null) that can be injected into the merge process.</param>
            <returns>True if the merge succeeded, false if the merge failed or is not possible.</returns>
        </member>
        <member name="T:CK.Core.Impl.CoreResources">
            <summary>
            Resource class, for looking up strings.
            </summary>
        </member>
        <member name="T:CK.Core.IUniqueId">
            <summary>
            Minimal interface that enables any type (specially reference type) to
            expose a <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="P:CK.Core.IUniqueId.UniqueId">
            <summary>
            Gets the unique identifier associated to this object.
            </summary>
        </member>
        <member name="T:CK.Core.CKReadOnlyCollectionOnICollection`1">
            <summary>
            Small adapter that exposes a <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> on a <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <typeparam name="T">Type of the collection items.</typeparam>
        </member>
        <member name="M:CK.Core.CKReadOnlyCollectionOnICollection`1.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKReadOnlyCollectionOnICollection`1"/> with a null <see cref="P:CK.Core.CKReadOnlyCollectionOnICollection`1.Values"/>.
            </summary>
        </member>
        <member name="M:CK.Core.CKReadOnlyCollectionOnICollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Initializes a new <see cref="T:CK.Core.CKReadOnlyCollectionOnICollection`1"/> on a <see cref="T:System.Collections.Generic.ICollection`1"/>
            for the <see cref="P:CK.Core.CKReadOnlyCollectionOnICollection`1.Values"/>.
            </summary>
            <param name="values">Collection to wrap.</param>
        </member>
        <member name="P:CK.Core.CKReadOnlyCollectionOnICollection`1.Values">
            <summary>
            Gets or sets the wrapped collection.
            </summary>
        </member>
        <member name="P:CK.Core.CKReadOnlyCollectionOnICollection`1.Count">
            <summary>
            Gets the count of items.
            </summary>
        </member>
        <member name="M:CK.Core.CKReadOnlyCollectionOnICollection`1.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns>An enumerator on the <see cref="P:CK.Core.CKReadOnlyCollectionOnICollection`1.Values"/>.</returns>
        </member>
        <member name="T:CK.Core.Debugging.ReadOnlyCollectionDebuggerView`1">
            <summary>
            Debugger object for <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>.
            </summary>
            <typeparam name="T">Type of elements in the collection.</typeparam>
        </member>
        <member name="M:CK.Core.Debugging.ReadOnlyCollectionDebuggerView`1.#ctor(System.Collections.Generic.IReadOnlyCollection{`0})">
            <summary>
            Called by the debugger when needed.
            </summary>
            <param name="collection">The collection to debug.</param>
        </member>
        <member name="P:CK.Core.Debugging.ReadOnlyCollectionDebuggerView`1.Items">
            <summary>
            Gets the items as a flattened array view.
            </summary>
        </member>
        <member name="T:CK.Core.Debugging.ReadOnlyCollectionDebuggerView`2">
            <summary>
            Debugger for adapters with two types (an exposed type and an inner type).
            </summary>
            <typeparam name="T">Type of the exposed element.</typeparam>
            <typeparam name="TInner">Type of the inner element.</typeparam>
        </member>
        <member name="M:CK.Core.Debugging.ReadOnlyCollectionDebuggerView`2.#ctor(System.Collections.Generic.IReadOnlyCollection{`0})">
            <summary>
            Called by the debugger when needed.
            </summary>
            <param name="collection">The collection to debug.</param>
        </member>
        <member name="P:CK.Core.Debugging.ReadOnlyCollectionDebuggerView`2.Items">
            <summary>
            Gets the items as a flattened array view.
            </summary>
        </member>
        <member name="T:CK.Core.ISimpleServiceContainer">
            <summary>
            Defines a container for services.
            </summary>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})">
            <summary>
            Registers a service associated to a callback (and an optional callback that will be called when the service will be removed).
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>
            is called and a service as been successfuly obtained.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Add(System.Type,System.Object,System.Action{System.Object})">
            <summary>
            Registers a service with its implementation (and an optional callback that will be called when the service will be removed).
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)">
            <summary>
            Unregisters a service. Can be called even if the service does not exist.
            The service is first removed and then the OnRemove associated action is called if it exists:
            this enables OnRemove action to be bound to a method that safely calls back this Remove method.
            </summary>
            <param name="serviceType">Service type to unregister.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Clear">
            <summary>
            Unregisters all the services. Any "on remove" actions are executed.
            </summary>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.AddDisabled(System.Type)">
            <summary>
            Disables a service: null will always be returned by this <see cref="M:System.IServiceProvider.GetService(System.Type)"/>
            regardless of any fallbacks that may exist for this container.
            </summary>
            <remarks>
            This is not the same as calling <see cref="M:CK.Core.ISimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})"/> with a null instance. A null instance for a service (a callback that always returns null)
            is nearly the same as calling <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>: any fallbacks (to a base <see cref="T:System.IServiceProvider"/> for example) can occur.
            This one is stronger since this must prevent fallbacks.
            </remarks>
            <param name="serviceType">Service type to disable. It must not already exist in this container otherwise an exception is thrown.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="T:CK.Core.SimpleServiceContainer">
            <summary>
            Service container (that is a <see cref="T:System.IServiceProvider"/>) subordinated to an optional base IServiceProvider 
            that acts as a fallback if the service is not found at this level.
            Service creation may be deferred thanks to callback registration and an optional remove callback can be registered
            with each entry.
            </summary>
            <remarks>
            This container is registered as the service associated to <see cref="T:System.IServiceProvider"/> and <see cref="T:CK.Core.ISimpleServiceContainer"/>
            thanks to the overridable <see cref="M:CK.Core.SimpleServiceContainer.GetDirectService(System.Type)"/>. This method may be overridden to return other built-in services: these services
            take precedence over the registered services.
            </remarks>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.SimpleServiceContainer"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.#ctor(System.IServiceProvider)">
            <summary>
            Initializes a new <see cref="T:CK.Core.SimpleServiceContainer"/> with a <see cref="P:CK.Core.SimpleServiceContainer.BaseProvider"/>.
            </summary>
            <param name="baseProvider">Base <see cref="T:System.IServiceProvider"/> provider.</param>
        </member>
        <member name="P:CK.Core.SimpleServiceContainer.BaseProvider">
            <summary>
            Gets or sets the <see cref="T:System.IServiceProvider"/> that is queried whenever a service
            is not found in this container.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})">
            <summary>
            Registers a service associated to a callback (and an optional callback that will be called when the service will be removed).
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.SimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.SimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>
            is called and a service as been successfully obtained.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Add(System.Type,System.Object,System.Action{System.Object})">
            <summary>
            Registers a service with its implementation (and an optional callback that will be called when the service will be removed).
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.SimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.SimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.AddDisabled(System.Type)">
            <summary>
            Disables a service: null will always be returned by this <see cref="M:System.IServiceProvider.GetService(System.Type)"/>
            regardless of any fallbacks from <see cref="P:CK.Core.SimpleServiceContainer.BaseProvider"/>. 
            Direct services returned by <see cref="M:CK.Core.SimpleServiceContainer.GetDirectService(System.Type)"/> can not be disabled.
            </summary>
            <remarks>
            This is not the same as calling <see cref="M:CK.Core.SimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})"/> with a null instance. A null instance for a service (a callback that always returns null)
            is nearly the same as calling <see cref="M:CK.Core.SimpleServiceContainer.Remove(System.Type)"/>: any fallbacks (to a base <see cref="T:System.IServiceProvider"/> for example) can occur.
            This is stronger since this must prevent fallbacks.
            </remarks>
            <param name="serviceType">Service type to disable. It must not already exist in this container otherwise an exception is thrown.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Remove(System.Type)">
            <summary>
            Unregisters a service. Can be called even if the service does not exist.
            The service is first removed and then the OnRemove associated action is called if it exists.
            </summary>
            <param name="serviceType">Service type to unregister.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Clear">
            <summary>
            Unregisters all the services. Any "on remove" actions are executed.
            </summary>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.GetService(System.Type)">
            <summary>
            Implements <see cref="M:System.IServiceProvider.GetService(System.Type)"/>.
            </summary>
            <param name="serviceType">Type of the service to obtain.</param>
            <returns>Built-in service, registered service, service from <see cref="P:CK.Core.SimpleServiceContainer.BaseProvider"/> or null.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.GetDirectService(System.Type)">
            <summary>
            Must return built-in services if any. These services take precedence over any registered services.
            This base implementation returns this object for <see cref="T:System.IServiceProvider"/> and <see cref="T:CK.Core.ISimpleServiceContainer"/>.
            </summary>
            <param name="serviceType">Type of the service to obtain.</param>
            <returns>A built-in service or null.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Finalize">
            <summary>
            Ensures that potential unmanaged resources are correctly released by calling <see cref="M:CK.Core.SimpleServiceContainer.Dispose(System.Boolean)"/> with false.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Dispose">
            <summary>
            Disposing calls <see cref="M:CK.Core.SimpleServiceContainer.Clear"/> to unregister all services. Any "on remove" actions are executed.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Dispose(System.Boolean)">
            <summary>
            When <paramref name="disposing"/> is true, calls <see cref="M:CK.Core.SimpleServiceContainer.Clear"/> to unregister all services. 
            Any "on remove" actions are executed.
            <param name="disposing">Whether <see cref="M:CK.Core.SimpleServiceContainer.Dispose"/> has been called.</param>
            </summary>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.DoAdd(System.Type,CK.Core.SimpleServiceContainer.ServiceEntry)">
            <summary>
            Correct ArgumentException throw by a Dictionary when adding an existing key. 
            </summary>
        </member>
        <member name="T:CK.Core.SetOperation">
            <summary>
            Defines the six basic operations available between two sets.
            </summary>
        </member>
        <member name="F:CK.Core.SetOperation.None">
            <summary>
            No operation.
            </summary>
        </member>
        <member name="F:CK.Core.SetOperation.Union">
            <summary>
            Union of the sets (keeps items of first or second set).
            </summary>
        </member>
        <member name="F:CK.Core.SetOperation.Intersect">
            <summary>
            Intersection of the sets (keeps only items that belong to both sets).
            </summary>
        </member>
        <member name="F:CK.Core.SetOperation.Except">
            <summary>
            Exclusion (keeps only items of the first that do not belong to the second one).
            </summary>
        </member>
        <member name="F:CK.Core.SetOperation.SymetricExcept">
            <summary>
            Symetric exclusion (keeps items that belong to first or second set but not to both) - The XOR operation.
            </summary>
        </member>
        <member name="F:CK.Core.SetOperation.Replace">
            <summary>
            Replace the first set by the second one.
            </summary>
        </member>
        <member name="T:CK.Core.SimpleTypeFinder">
            <summary>
            Offers a global <see cref="P:CK.Core.SimpleTypeFinder.Resolver"/> function that replaces <see cref="M:System.Type.GetType(System.String,System.Boolean)"/>. 
            Default implementation is set to <see cref="M:CK.Core.SimpleTypeFinder.WeakResolver(System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:CK.Core.SimpleTypeFinder.Resolver">
            <summary>
            Gets or sets a global resolver. This resolver MUST always throw a <see cref="T:System.TypeLoadException"/> 
            when the boolean parameter is true: this is what <see cref="M:CK.Core.SimpleTypeFinder.StandardResolver(System.String,System.Boolean)"/> do.
            Defaults to <see cref="M:CK.Core.SimpleTypeFinder.WeakResolver(System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:CK.Core.SimpleTypeFinder.RawGetType">
            <summary>
            The <see cref="M:System.Type.GetType(System.String,System.Boolean)"/> function that <see cref="M:CK.Core.SimpleTypeFinder.StandardResolver(System.String,System.Boolean)"/> 
            and <see cref="M:CK.Core.SimpleTypeFinder.WeakResolver(System.String,System.Boolean)"/> use. Another function may be injected in advanced scenario if needed.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.WeakResolver(System.String,System.Boolean)">
            <summary>
            An implementation of <see cref="P:CK.Core.SimpleTypeFinder.Resolver"/> that can be used to load types regardless of 
            the version, culture, architecture and public key token (strongly-named assemblies) of the type names.
            (See <see cref="M:CK.Core.SimpleTypeFinder.WeakenAssemblyQualifiedName(System.String,System.String@)"/>.)
            </summary>
            <remarks>
            The type name used is: "NamespaceOfTheType.TypeName, AssemblyName".
            </remarks>
            <returns>The type or null if not found and <paramref name="throwOnError"/> is false.</returns>
            <exception cref="T:System.TypeLoadException">
            When <paramref name="throwOnError"/> is true, always throws a type load exception.
            The original error (not a <see cref="T:System.TypeLoadException"/>) is available in the <see cref="P:System.Exception.InnerException"/>.
            </exception>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.StandardResolver(System.String,System.Boolean)">
            <summary>
            Direct implementation that checks that the assembly qualified name set as parameter is valid, 
            then calls <see cref="M:System.Type.GetType(System.String,System.Boolean)"/> and converts any exception that may be raised
            to <see cref="T:System.TypeLoadException"/>.
            </summary>
            <param name="assemblyQualifiedName">The assembly qualified name of a type.</param>
            <param name="throwOnError">
            True to ALWAYS throw a <see cref="T:System.TypeLoadException"/> if the type is not found.
            It may also throw <see cref="T:System.ArgumentNullException"/> and <see cref="T:System.ArgumentException"/> when the assembly qualified name is not valid
            False prevents any exception from being thrown and simply returns null.
            </param>
            <returns>The type or null if not found and <paramref name="throwOnError"/> is false.</returns>
            <exception cref="T:System.TypeLoadException">
            When <paramref name="throwOnError"/> is true, always throws a type load exception.
            The original error (not a <see cref="T:System.TypeLoadException"/>) is available in the <see cref="P:System.Exception.InnerException"/>.
            </exception>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.WeakenAssemblyQualifiedName(System.String,System.String@)">
            <summary>
            Helper method to remove version, architecture, publicTokenKey and culture from the assembly qualified name into its assembly name passed as parameter.
            "CK.Core.SimpleTypeFinder, CK.Core, version=1.0.0, culture='fr-FR'" gives "CK.Core.SimpleTypeFinder, CK.Core".
            Used to remove strong name from an strongly-named assembly qualified name
            </summary>
            <param name="assemblyQualifiedName">The assembly qualified name to weaken.</param>
            <param name="weakTypeName">The weakened assembly qualified name on output or an empty string.</param>
            <returns>True if the split has been successfully done. False otherwise.</returns>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.SplitAssemblyQualifiedName(System.String,System.String@,System.String@)">
            <summary>
            Helper method to split the assembly qualified name into its assembly name and full type name.
            "CK.Core.SimpleTypeFinder, CK.Core, version=1.0.0, culture='fr-FR'" gives "CK.Core.SimpleTypeFinder" and "CK.Core, version=1.0.0, culture='fr-FR'".
            </summary>
            <param name="assemblyQualifiedName">The assembly qualified name to split.</param>
            <param name="fullTypeName">Full type name on output or an empty string.</param>
            <param name="assemblyFullName">Weaken type name on output or an empty string.</param>
            <returns>True if the weakening has been successfully done. False otherwise.</returns>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.SplitAssemblyFullName(System.String,System.String@,System.String@)">
            <summary>
            Helper method to split an assembly full name in two parts: 
            "CK.Core, version=1.0.0, culture='fr-FR'" gives "CK.Core" and "version=1.0.0, culture='fr-FR'".
            </summary>
            <param name="assemblyFullName">The assembly full name.</param>
            <param name="assemblyName">Set to assembly name only.</param>
            <param name="versionCultureAndPublicKeyToken">Set to extra information.</param>
            <returns>True if the split worked. False otherwise.</returns>
        </member>
        <member name="T:CK.Core.TemporaryFile">
            <summary>
            Small helper to automatically delete a temporary file. 
            It is mainly a secure wrapper around <see cref="M:System.IO.Path.GetTempFileName">GetTempFileName</see> that 
            creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file: the <see cref="P:Path"/>
            property exposes it. This file is flagged by default with <see cref="F:System.IO.FileAttributes.Temporary"/> (short-lived): it will automatically be 
            deleted by the Operating System during if it is still here on reboot.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor">
            <summary>
            Initializes a new short lived <see cref="T:CK.Core.TemporaryFile"/>.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor(System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.TemporaryFile"/>.
            When <paramref name="shortLived"/> is true, the <see cref="F:System.IO.FileAttributes.Temporary"/> is set on the file.
            </summary>
            <param name="shortLived">True to set the <see cref="F:System.IO.FileAttributes.Temporary"/> on the file.</param>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor(System.String)">
            <summary>
            Initializes a new short lived <see cref="T:CK.Core.TemporaryFile"/> with an extension - the file will have a name looking like : xxxx.tmp.extension        
            </summary>
            <param name="extension">The extension of the file (example : '.png' and 'png' would both work) </param>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes a new <see cref="T:CK.Core.TemporaryFile"/> with an extension.
            When <paramref name="shortLived"/> is true, the <see cref="F:System.IO.FileAttributes.Temporary"/> is set on the file.
            The file will have a name looking like : xxxx.tmp.extension
            </summary>
            <param name="shortLived">True to set the <see cref="F:System.IO.FileAttributes.Temporary"/> on the file.</param>
            <param name="extension">Optional extension of the file (example : '.png' and 'png' would both work).</param>
            <remarks>
            When extension is ".", the final path will end with a ".".
            </remarks>
        </member>
        <member name="M:CK.Core.TemporaryFile.Finalize">
            <summary>
            Finalizer attempts to delete the file.
            </summary>
        </member>
        <member name="P:CK.Core.TemporaryFile.Path">
            <summary>
            Gets the complete file path of the temporary file.
            It is <see cref="F:System.String.Empty"/> when the file has been <see cref="M:CK.Core.TemporaryFile.Detach"/>ed.
            The file is not opened but exists, initially empty.
            </summary>
        </member>
        <member name="P:CK.Core.TemporaryFile.IsDetached">
            <summary>
            Gets whether the temporary file is detached (its <see cref="P:CK.Core.TemporaryFile.Path"/> is <see cref="F:System.String.Empty"/>).
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.Detach">
            <summary>
            Detaches the temporary file: it will no more be automatically destroyed.
            When created short-lived (see <see cref="F:System.IO.FileAttributes.Temporary"/>), this flag is not reset: the 
            file will be destroyed by the Operating System on the bext reboot.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.Dispose">
            <summary>
            Attempts to delete the temporary file.
            </summary>
        </member>
        <member name="T:CK.Core.Util">
            <summary>
            Utility class.
            Offers useful functions, constants, singletons and delegates.
            </summary>
        </member>
        <member name="F:CK.Core.Util.UtcMinValue">
            <summary>
            Represents the smallest possible value for a <see cref="T:System.DateTime"/> in <see cref="F:System.DateTimeKind.Utc"/>.         
            </summary>
        </member>
        <member name="F:CK.Core.Util.UtcMaxValue">
            <summary>
            Represents the largest possible value for a <see cref="T:System.DateTime"/> in <see cref="F:System.DateTimeKind.Utc"/>.         
            </summary>
        </member>
        <member name="T:CK.Core.Util.Array">
            <summary>
            Supports Empty&lt;T&gt;() for all DNX targets.
            </summary>
        </member>
        <member name="M:CK.Core.Util.Array.Empty``1">
            <summary>
            Gets an empty array for a type.
            </summary>
            <typeparam name="T">Type of the array items.</typeparam>
            <returns>An empty array.</returns>
        </member>
        <member name="M:CK.Core.Util.ActionDispose(System.IDisposable)">
            <summary>
            Centralized <see cref="M:System.IDisposable.Dispose"/> action call: it adapts an <see cref="T:System.IDisposable"/> interface to an <see cref="T:System.Action"/>.
            Can be safely called if <paramref name="obj"/> is null. 
            See <see cref="M:CK.Core.Util.CreateDisposableAction(System.Action)"/> to wrap an action in a <see cref="T:System.IDisposable"/> interface.
            </summary>
            <param name="obj">The disposable object to dispose (can be null).</param>
        </member>
        <member name="M:CK.Core.Util.CreateDisposableAction(System.Action)">
            <summary>
            Wraps an action in a <see cref="T:System.IDisposable"/> interface
            Can be safely called if <paramref name="a"/> is null (the dispose call will do nothing) and in multi threaded context:
            the call to action will be done once and only once by the first call to dispose.
            See <see cref="M:CK.Core.Util.ActionDispose(System.IDisposable)"/> to adapt an IDisposable interface to an <see cref="T:System.Action"/>.
            </summary>
            <param name="a">The action to call when <see cref="M:System.IDisposable.Dispose"/> is called.</param>
        </member>
        <member name="F:CK.Core.Util.EmptyDisposable">
            <summary>
            A void, immutable, <see cref="T:System.IDisposable"/> that does absolutely nothing.
            </summary>
        </member>
        <member name="F:CK.Core.Util.UnixEpoch">
            <summary>
            Unix Epoch (1st of january 1970).
            </summary>
        </member>
        <member name="F:CK.Core.Util.SqlServerEpoch">
            <summary>
            Sql Server Epoch (1st of january 1900): this is the 0 legacy datetime.
            </summary>
        </member>
        <member name="F:CK.Core.Util.EmptyVersion">
            <summary>
            The 0.0.0.0 Version.
            </summary>
        </member>
        <member name="M:CK.Core.Util.ActionVoid``1(``0)">
            <summary>
            Centralized void action call for any type. 
            This method is one of the safest method never written in the world. 
            It does absolutely nothing.
            </summary>
            <param name="obj">Any object.</param>
        </member>
        <member name="M:CK.Core.Util.ActionVoid``2(``0,``1)">
            <summary>
            Centralized void action call for any pair of types. 
            This method is one of the safest method never written in the world. 
            It does absolutely nothing.
            </summary>
            <param name="o1">Any object.</param>
            <param name="o2">Any object.</param>
        </member>
        <member name="M:CK.Core.Util.ActionVoid``3(``0,``1,``2)">
            <summary>
            Centralized void action call for any 3 types. 
            This method is one of the safest method never written in the world. 
            It does absolutely nothing.
            </summary>
            <param name="o1">Any object.</param>
            <param name="o2">Any object.</param>
            <param name="o3">Any object.</param>
        </member>
        <member name="M:CK.Core.Util.FuncIdentity``1(``0)">
            <summary>
            Centralized identity function for any type.
            </summary>
            <typeparam name="T">Type of the function parameter and return value.</typeparam>
            <param name="value">Any value returned unchanged.</param>
            <returns>The <paramref name="value"/> provided is returned as-is.</returns>
        </member>
        <member name="M:CK.Core.Util.BinarySearch``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Int32,``0,System.Comparison{``0})">
            <summary>
            Binary search implementation that relies on a <see cref="T:System.Comparison`1"/>.
            </summary>
            <typeparam name="T">Type of the elements.</typeparam>
            <param name="sortedList">Read only list of elements.</param>
            <param name="startIndex">The starting index in the list.</param>
            <param name="length">The number of elements to consider in the list.</param>
            <param name="value">The value to locate.</param>
            <param name="comparison">The comparison function.</param>
            <returns>Same as <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: negative index if not found which is the bitwise complement of (the index of the next element plus 1).</returns>
        </member>
        <member name="M:CK.Core.Util.BinarySearch``2(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Int32,``1,System.Func{``0,``1,System.Int32})">
            <summary>
            Binary search implementation that relies on an extended comparer: a function that knows how to 
            compare the elements of the list to a key of another type.
            </summary>
            <typeparam name="T">Type of the elements.</typeparam>
            <typeparam name="TKey">Type of the key.</typeparam>
            <param name="sortedList">Read only list of elements.</param>
            <param name="startIndex">The starting index in the list.</param>
            <param name="length">The number of elements to consider in the list.</param>
            <param name="key">The value of the key.</param>
            <param name="comparison">The comparison function.</param>
            <returns>Same as <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: negative index if not found which is the bitwise complement of (the index of the next element plus 1).</returns>
        </member>
        <member name="M:CK.Core.Util.BinarySearch``2(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Int32,``1)">
            <summary>
            Binary search implementation that relies on <see cref="T:System.IComparable`1"/> implemented by the <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type of the elements. It must implement <see cref="T:System.IComparable`1"/>.</typeparam>
            <typeparam name="TValue">Type of the value.</typeparam>
            <param name="sortedList">Read only list of elements.</param>
            <param name="startIndex">The starting index in the list.</param>
            <param name="length">The number of elements to consider in the list.</param>
            <param name="value">The value to locate.</param>
            <returns>Same as <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: negative index if not found which is the bitwise complement of (the index of the next element plus 1).</returns>
        </member>
        <member name="M:CK.Core.Util.BinarySearch``2(System.Collections.Generic.IReadOnlyList{``0},``1)">
            <summary>
            Binary search implementation that relies on <see cref="T:System.IComparable`1"/> implemented by the <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type of the elements. It must implement <see cref="T:System.IComparable`1"/>.</typeparam>
            <typeparam name="TValue">Type of the value.</typeparam>
            <param name="sortedList">Read only list of elements.</param>
            <param name="value">The value to locate.</param>
            <returns>Same as <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: negative index if not found which is the bitwise complement of (the index of the next element plus 1).</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedSet``1(``0@,System.Func{``0,``0})">
            <summary>
            Thread-safe way to set any reference type. Uses <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/> and <see cref="T:System.Threading.SpinWait"/>.
            </summary>
            <typeparam name="T">Any reference type.</typeparam>
            <param name="target">Reference (address) to set.</param>
            <param name="transformer">Function that knows how to obtain the desired object from the current one. This function may be called more than once.</param>
            <returns>The object that has actually been set. Note that it may differ from the "current" target value if another thread already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedSet``2(``0@,``1,System.Func{``0,``1,``0})">
            <summary>
            Thread-safe way to set any reference type. Uses <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/> and <see cref="T:System.Threading.SpinWait"/>.
            </summary>
            <typeparam name="T">Any reference type.</typeparam>
            <typeparam name="TArg">Type of the first parameter.</typeparam>
            <param name="target">Reference (address) to set.</param>
            <param name="a">Argument of the transformer.</param>
            <param name="transformer">Function that knows how to obtain the desired object from the current one. This function may be called more than once.</param>
            <returns>The object that has actually been set. Note that it may differ from the "current" target value if another thread already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedRemove``1(``0[]@,``0)">
            <summary>
            Atomically removes an item in an array.
            </summary>
            <typeparam name="T">Type of the item array.</typeparam>
            <param name="items">Reference (address) of the array. Can be null.</param>
            <param name="o">Item to remove.</param>
            <returns>The array containing the new item. Note that it may differ from the "current" items content since another thread may have already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedRemove``1(``0[]@,System.Func{``0,System.Boolean})">
            <summary>
            Atomically removes the first item from an array that matches a predicate.
            </summary>
            <typeparam name="T">Type of the item array.</typeparam>
            <param name="items">Reference (address) of the array. Can be null.</param>
            <param name="predicate">Predicate that identifies the item to remove.</param>
            <returns>The array containing the new item. Note that it may differ from the "current" items content since another thread may have already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedRemoveAll``1(``0[]@,System.Func{``0,System.Boolean})">
            <summary>
            Atomically removes one or more items from an array that match a predicate.
            </summary>
            <typeparam name="T">Type of the item array.</typeparam>
            <param name="items">Reference (address) of the array. Can be null.</param>
            <param name="predicate">Predicate that identifies items to remove.</param>
            <returns>The array containing the new item. Note that it may differ from the "current" items content since another thread may have already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedAddUnique``1(``0[]@,``0,System.Boolean)">
            <summary>
            Atomically adds an item to an array (that can be null) if it does not already exist in the array.
            </summary>
            <typeparam name="T">Type of the item array.</typeparam>
            <param name="items">Reference (address) of the array. Can be null.</param>
            <param name="o">The item to insert at position 0 (if <paramref name="prepend"/> is true) or at the end only if it does not already appear in the array.</param>
            <param name="prepend">True to insert the item at the head of the array (index 0) instead of at its end.</param>
            <returns>The array containing the new item. Note that it may differ from the "current" items content since another thread may have already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedAdd``1(``0[]@,``0,System.Boolean)">
            <summary>
            Atomically adds an item to an array (that can be null).
            </summary>
            <typeparam name="T">Type of the item array.</typeparam>
            <param name="items">Reference (address) of the array. Can be null.</param>
            <param name="o">The item to insert at position 0 (if <paramref name="prepend"/> is true) or at the end.</param>
            <param name="prepend">True to insert the item at the head of the array (index 0) instead of at its end.</param>
            <returns>The array containing the new item. Note that it may differ from the "current" items content since another thread may have already changed it.</returns>
        </member>
        <member name="M:CK.Core.Util.InterlockedAdd``2(``0[]@,System.Func{``1,System.Boolean},System.Func{``1},System.Boolean)">
            <summary>
            Atomically adds an item to an existing array (that can be null) if no existing item satisfies a condition.
            </summary>
            <typeparam name="T">Type of the item array.</typeparam>
            <typeparam name="TItem">Type of the item to add: can be any specialization of T.</typeparam>
            <param name="items">Reference (address) of the array. Can be null.</param>
            <param name="tester">Predicate that must be satisfied for at least one existing item.</param>
            <param name="factory">Factory that will be called if no existing item satisfies <paramref name="tester"/>. It will be called only once if needed.</param>
            <param name="prepend">True to insert the item at the head of the array (index 0) instead of at its end.</param>
            <returns>
            The array containing the an item that satisfies the tester function. 
            Note that it may differ from the "current" items content since another thread may have already changed it.
            </returns>
            <remarks>
            The factory function MUST return an item that satisfies the tester function otherwise a <see cref="T:System.InvalidOperationException"/> is thrown.
            </remarks>
        </member>
        <member name="T:CK.Core.Util.Hash">
            <summary>
            Provides methods to combine hash values: use <see cref="P:CK.Core.Util.Hash.StartValue"/> and then 
            chain calls to the <see cref="M:Combine"/> methods.
            Based on Daniel J. Bernstein algorithm (http://cr.yp.to/cdb/cdb.txt).
            </summary>
        </member>
        <member name="P:CK.Core.Util.Hash.StartValue">
             <summary>
             Gets a very classical start value (see remarks) that can be then be used 
             by the multiple <see cref="M:Combine"/> methods. Use <see cref="M:System.Int64.GetHashCode"/> to
             obtain a final integer (Int32) hash code.
             </summary>
             <remarks>
             It seems that this value has nothing special (mathematically speaking) except that it 
             has been used and reused by many people since DJB choose it.
            </remarks>
        </member>
        <member name="M:CK.Core.Util.Hash.Combine(System.Int64,System.Int32)">
            <summary>
            Combines an existing hash value with a new one.
            </summary>
            <param name="hash">Current hash.</param>
            <param name="value">Value to combine.</param>
            <returns>A combined hash.</returns>
        </member>
        <member name="M:CK.Core.Util.Hash.Combine(System.Int64,System.Object)">
            <summary>
            Combines an existing hash value with an object's hash (object can be null).
            </summary>
            <param name="hash">Current hash.</param>
            <param name="o">Object whose hash must be combined (can be null).</param>
            <returns>A combined hash.</returns>
        </member>
        <member name="M:CK.Core.Util.Hash.Combine(System.Int64,System.Collections.IEnumerable)">
            <summary>
            Combines an existing hash value with multiples object's hash.
            </summary>
            <param name="hash">Current hash.</param>
            <param name="c">Multiple objects. Can be null.</param>
            <returns>A combined hash.</returns>
        </member>
        <member name="M:CK.Core.Util.Hash.Combine(System.Int64,System.Object[])">
            <summary>
            Combines an existing hash value with multiples object's written directly as parameters.
            </summary>
            <param name="hash">Current hash.</param>
            <param name="objects">Multiple objects.</param>
            <returns>A combined hash.</returns>
        </member>
        <member name="T:SimpleGitVersionInfoAttribute">
            <summary>
            Automatically generated by SimpleGitVersionTask 5.0.0-delta.2. 
            </summary>
        </member>
    </members>
</doc>
