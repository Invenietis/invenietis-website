<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CK.Monitoring</name>
    </assembly>
    <members>
        <member name="T:CK.Monitoring.GrandOutputChannelConfigData">
            <summary>
            Configuration for a channel. A channel is a route that receive outputs from monitors: this configuration is associated to a <see cref="T:CK.RouteConfig.RouteConfiguration"/> 
            or a <see cref="T:CK.RouteConfig.SubRouteConfiguration"/> object.
            Currently, the only configuration is the <see cref="F:CK.Monitoring.GrandOutputChannelConfigData.MinimalFilter"/> of the channel.
            </summary>
        </member>
        <member name="F:CK.Monitoring.GrandOutputChannelConfigData.MinimalFilter">
            <summary>
            The minimal filter that will be applied to moniors that are bound (by their current <see cref="P:CK.Core.IActivityMonitor.Topic"/>) to this channel.
            Defaults to <see cref="F:CK.Core.LogFilter.Undefined"/>.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputChannelConfigData.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:CK.Monitoring.GrandOutputChannelConfigData"/>.
            The <see cref="F:CK.Monitoring.GrandOutputChannelConfigData.MinimalFilter"/> is <see cref="F:CK.Core.LogFilter.Undefined"/>.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputChannelConfigData.#ctor(System.Xml.Linq.XElement)">
            <summary>
            Reads a <see cref="T:System.Xml.Linq.XElement"/> with an optional "MinimalFilter" attribute.
            </summary>
            <param name="xml">The xml element.</param>
        </member>
        <member name="T:CK.Monitoring.GrandOutputConfiguration">
            <summary>
            Defines configuration for <see cref="T:CK.Monitoring.GrandOutput"/>.
            This object is not thread safe. New GrandOutputConfiguration can be created when needed (and 
            method <see cref="M:CK.Monitoring.GrandOutputConfiguration.LoadFromFile(System.String,CK.Core.IActivityMonitor)"/> or <see cref="M:CK.Monitoring.GrandOutputConfiguration.Load(System.Xml.Linq.XElement,CK.Core.IActivityMonitor)"/> called).
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputConfiguration.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Monitoring.GrandOutputConfiguration"/>.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputConfiguration.LoadFromFile(System.String,CK.Core.IActivityMonitor)">
            <summary>
            Loads this configuration from a <see cref="T:System.Xml.Linq.XElement"/>.
            </summary>
            <param name="path">Path to the configuration xml file.</param>
            <param name="monitor">Monitor that will be used.</param>
            <returns>True on success, false if the configuration can not be read.</returns>
        </member>
        <member name="M:CK.Monitoring.GrandOutputConfiguration.Load(System.Xml.Linq.XElement,CK.Core.IActivityMonitor)">
            <summary>
            Loads this configuration from a <see cref="T:System.Xml.Linq.XElement"/>.
            </summary>
            <param name="e">The xml element: its name must be GrandOutputConfiguration.</param>
            <param name="monitor">Monitor that will be used.</param>
            <returns>True on success, false if the configuration can not be read.</returns>
        </member>
        <member name="P:CK.Monitoring.GrandOutputConfiguration.GlobalDefaultFilter">
            <summary>
            Gets or sets the default filter for the application domain. 
            This value is set on the static <see cref="P:CK.Core.ActivityMonitor.DefaultFilter"/> by <see cref="M:CK.Monitoring.GrandOutput.SetConfiguration(CK.Monitoring.GrandOutputConfiguration,CK.Core.IActivityMonitor,System.Int32)"/>
            if and only if the configured GrandOutput is the <see cref="P:CK.Monitoring.GrandOutput.Default"/>.
            </summary>
        </member>
        <member name="P:CK.Monitoring.GrandOutputConfiguration.SourceOverrideFilter">
            <summary>
            Gets or sets the source file filter mapping: when not null and if <see cref="P:CK.Monitoring.GrandOutputConfiguration.SourceOverrideFilterApplicationMode"/> is <see cref="F:CK.Monitoring.SourceFilterApplyMode.Apply"/> 
            or <see cref="F:CK.Monitoring.SourceFilterApplyMode.ClearThenApply"/> the <see cref="M:CK.Monitoring.GrandOutput.SetConfiguration(CK.Monitoring.GrandOutputConfiguration,CK.Core.IActivityMonitor,System.Int32)"/> method clears any existing source file filters and sets this ones.
            </summary>
        </member>
        <member name="P:CK.Monitoring.GrandOutputConfiguration.SourceOverrideFilterApplicationMode">
            <summary>
            Gets or sets how global source filter must be impacted.
            </summary>
        </member>
        <member name="P:CK.Monitoring.GrandOutputConfiguration.ChannelsConfiguration">
            <summary>
            Gets or sets the channels configuration. 
            <see cref="T:CK.RouteConfig.RouteConfiguration"/> is not a class specific to GrandOutput channels: care must be taken when working directly 
            with this object (see remarks). Loading from xml should be used.
            </summary>
            <remarks>
            <see cref="P:CK.RouteConfig.RouteConfiguration.ConfigData"/> of the main route and all sub routes must be set to a <see cref="T:CK.Monitoring.GrandOutputChannelConfigData"/> object.
            All actions added to the routes must inherit from <see cref="T:CK.Monitoring.GrandOutputHandlers.HandlerConfiguration"/>.
            </remarks>
        </member>
        <member name="T:CK.Monitoring.SourceFilterApplyMode">
            <summary>
            Defines how the <see cref="T:CK.Monitoring.GrandOutputConfiguration"/> applies its <see cref="P:CK.Monitoring.GrandOutputConfiguration.SourceOverrideFilter"/>
            to the application domain's global <see cref="F:CK.Core.ActivityMonitor.SourceFilter.FilterSource"/>.
            </summary>
        </member>
        <member name="F:CK.Monitoring.SourceFilterApplyMode.None">
            <summary>
            Source filters is ignored.
            </summary>
        </member>
        <member name="F:CK.Monitoring.SourceFilterApplyMode.Clear">
            <summary>
            Clears the current <see cref="F:CK.Core.ActivityMonitor.SourceFilter.FilterSource"/>.
            </summary>
        </member>
        <member name="F:CK.Monitoring.SourceFilterApplyMode.ClearThenApply">
            <summary>
            Clears the current <see cref="F:CK.Core.ActivityMonitor.SourceFilter.FilterSource"/> and then applies the new ones.
            </summary>
        </member>
        <member name="F:CK.Monitoring.SourceFilterApplyMode.Apply">
            <summary>
            Applies the filters.
            </summary>
        </member>
        <member name="T:CK.Monitoring.XmlMonitoringExtensions">
            <summary>
            Helpers to read XML configurations.
            </summary>
        </member>
        <member name="M:CK.Monitoring.XmlMonitoringExtensions.GetRequiredAttributeLogFilter(System.Xml.Linq.XElement,System.String)">
            <summary>
            Reads a <see cref="T:CK.Core.LogFilter"/> that must exist.
            </summary>
            <param name="this">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
            <returns>A LogFilter.</returns>
        </member>
        <member name="M:CK.Monitoring.XmlMonitoringExtensions.GetAttributeLogFilter(System.Xml.Linq.XElement,System.String,System.Boolean)">
            <summary>
            Reads a <see cref="T:CK.Core.LogFilter"/>.
            </summary>
            <param name="this">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="fallbackToUndefined">True to return <see cref="F:CK.Core.LogFilter.Undefined"/> instead of null when not found.</param>
            <returns>A nullable LogFilter.</returns>
        </member>
        <member name="T:CK.Monitoring.GrandOutput">
            <summary>
            A GrandOutput collects activity of multiple <see cref="T:CK.Core.IActivityMonitor"/>. It routes log events to 
            multiple channels based on <see cref="P:CK.Core.IActivityMonitor.Topic"/>.
            
            It is usually useless to explicitly create an instance of GrandOutput: the <see cref="P:CK.Monitoring.GrandOutput.Default"/> one is 
            available as soon as <see cref="M:CK.Monitoring.GrandOutput.EnsureActiveDefault(System.Action{CK.Monitoring.GrandOutput})"/> (or <see cref="M:CK.Monitoring.GrandOutput.EnsureActiveDefaultWithDefaultSettings(CK.Core.IActivityMonitor)"/>) is called 
            and will be automatically used by new <see cref="T:CK.Core.ActivityMonitor"/>.
            </summary>
        </member>
        <member name="P:CK.Monitoring.GrandOutput.Default">
            <summary>
            Gets the default <see cref="T:CK.Monitoring.GrandOutput"/> for the current Application Domain.
            Note that <see cref="M:CK.Monitoring.GrandOutput.EnsureActiveDefault(System.Action{CK.Monitoring.GrandOutput})"/> must have been called, otherwise this static property is null.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutput.EnsureActiveDefault(System.Action{CK.Monitoring.GrandOutput})">
            <summary>
            Ensures that the <see cref="P:CK.Monitoring.GrandOutput.Default"/> GrandOutput is created and that any <see cref="T:CK.Core.ActivityMonitor"/> that will be created in this
            application domain will automatically have a <see cref="T:CK.Monitoring.GrandOutputClient"/> registered for this Default GrandOutput.
            Use <see cref="M:CK.Monitoring.GrandOutput.EnsureActiveDefaultWithDefaultSettings(CK.Core.IActivityMonitor)"/> to initially configure this default.
            </summary>
            <param name="configurator">
            Optional action that can configure the default GrandOutput.
            If specified will be called after the creation of a new GrandOutput: it will not be called 
            if a <see cref="P:CK.Monitoring.GrandOutput.Default"/> is already available.
            This parameter is optional since you can configure it at any time.
            </param>
            <returns>The Default GrandOutput.</returns>
            <remarks>
            This method is thread-safe (a simple lock protects it) and uses a <see cref="F:CK.Core.ActivityMonitor.AutoConfiguration"/> action 
            that <see cref="M:CK.Monitoring.GrandOutput.Register(CK.Core.IActivityMonitor)"/>s newly created <see cref="T:CK.Core.ActivityMonitor"/>.
            </remarks>
        </member>
        <member name="M:CK.Monitoring.GrandOutput.#ctor(CK.Monitoring.IGrandOutputDispatcherStrategy)">
            <summary>
            Initializes a new <see cref="T:CK.Monitoring.GrandOutput"/>. 
            </summary>
            <param name="dispatcherStrategy">Strategy to use to handle the throughput.</param>
        </member>
        <member name="M:CK.Monitoring.GrandOutput.Register(CK.Core.IActivityMonitor)">
            <summary>
            Ensures that a client for this GrandOutput is registered on a monitor.
            </summary>
            <param name="monitor">The monitor onto which a <see cref="T:CK.Monitoring.GrandOutputClient"/> must be registered.</param>
            <returns>A newly created client or the already existing one.</returns>
        </member>
        <member name="P:CK.Monitoring.GrandOutput.GrandOutputMinimalFilter">
            <summary>
            Gets or sets the minimal filter that monitors created for the 
            GrandOutput itself will use.
            Defaults to <see cref="F:CK.Core.LogFilter.Release"/> (this should be changed only for debugging reasons).
            </summary>
        </member>
        <member name="P:CK.Monitoring.GrandOutput.LostEventCount">
            <summary>
            Gets the number of lost events since this <see cref="T:CK.Monitoring.GrandOutput"/> has been created.
            </summary>
        </member>
        <member name="P:CK.Monitoring.GrandOutput.MaxQueuedCount">
            <summary>
            Maximal queue size that has been used.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutput.RegisterGlobalSink(CK.Monitoring.IGrandOutputSink)">
            <summary>
            Registers a <see cref="T:CK.Monitoring.IGrandOutputSink"/>.
            </summary>
            <param name="sink">The sink to register.</param>
        </member>
        <member name="M:CK.Monitoring.GrandOutput.UnregisterGlobalSink(CK.Monitoring.IGrandOutputSink)">
            <summary>
            Unregisters a <see cref="T:CK.Monitoring.IGrandOutputSink"/>.
            </summary>
            <param name="sink">The sink to unregister.</param>
        </member>
        <member name="P:CK.Monitoring.GrandOutput.ConfigurationAttemptCount">
            <summary>
            Gets the total number of calls to <see cref="M:CK.Monitoring.GrandOutput.SetConfiguration(CK.Monitoring.GrandOutputConfiguration,CK.Core.IActivityMonitor,System.Int32)"/> (and to <see cref="M:CK.Monitoring.GrandOutput.Dispose"/> method).
            This can be used to call <see cref="M:CK.Monitoring.GrandOutput.WaitForNextConfiguration(System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutput.SetConfiguration(CK.Monitoring.GrandOutputConfiguration,CK.Core.IActivityMonitor,System.Int32)">
            <summary>
            Attempts to set a new configuration.
            </summary>
            <param name="config">The configuration that must be set.</param>
            <param name="monitor">Optional monitor.</param>
            <param name="millisecondsBeforeForceClose">Optional timeout to wait before forcing the close of the currently active configuration.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:CK.Monitoring.GrandOutput.WaitForNextConfiguration(System.Int32,System.Int32)">
            <summary>
            Blocks the caller until the current <see cref="P:CK.Monitoring.GrandOutput.ConfigurationAttemptCount"/> is greater or equal to the given number and the last 
            configuration has been applied (or this object is disposed).
            </summary>
            <param name="configurationAttemptCount">The number of configuration attempt count to wait for.</param>
            <param name="millisecondsTimeout">Maximum number of milliseconds to wait. Use <see cref="F:System.Threading.Timeout.Infinite"/> or -1 for no limit.</param>
            <returns>False if specified timeout expired.</returns>
        </member>
        <member name="M:CK.Monitoring.GrandOutput.ObtainChannel(System.String)">
            <summary>
            Obtains an actual channel based on the activity <see cref="P:CK.Core.IActivityMonitor.Topic"/> (null when .
            This is called on the monitor's thread.
            </summary>
            <param name="topic">The topic. Used as the key to find an actual Channel that must handle the log events.</param>
            <returns>A channel for the topic (or an internal BufferingChannel if a configuration is being applied) or null if the GrandOutput has been disposed.</returns>
        </member>
        <member name="M:CK.Monitoring.GrandOutput.OnConfigurationClosing(System.Object,CK.RouteConfig.ConfiguredRouteHost{CK.Monitoring.GrandOutputHandlers.HandlerBase,CK.Monitoring.IChannel}.ConfigurationClosingEventArgs)">
            <summary>
            This is called by the host when current configuration must be closed.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutput.SignalConfigurationChanged">
            <summary>
            Signals the clients referenced by weak refs that they need to obtain a new channel
            and returns true if at least one weak ref is not alive.
            </summary>
        </member>
        <member name="P:CK.Monitoring.GrandOutput.IsDisposed">
            <summary>
            Gets whether this GrandOutput has been disposed.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutput.Dispose(CK.Core.IActivityMonitor,System.Int32)">
            <summary>
            Closes this <see cref="T:CK.Monitoring.GrandOutput"/>.
            </summary>
            <param name="monitor">Monitor that will be used. Must not be null.</param>
            <param name="millisecondsBeforeForceClose">Maximal time to wait for current routes to be unlocked (see <see cref="T:CK.RouteConfig.IRouteConfigurationLock"/>).</param>
        </member>
        <member name="M:CK.Monitoring.GrandOutput.Dispose">
            <summary>
            Calls <see cref="M:CK.Monitoring.GrandOutput.Dispose(CK.Core.IActivityMonitor,System.Int32)"/> with a <see cref="T:CK.Core.SystemActivityMonitor"/> and <see cref="F:System.Threading.Timeout.Infinite"/>.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutput.EnsureActiveDefaultWithDefaultSettings(CK.Core.IActivityMonitor)">
            <summary>
            Ensures that the <see cref="P:CK.Monitoring.GrandOutput.Default"/> GrandOutput is created (see <see cref="M:CK.Monitoring.GrandOutput.EnsureActiveDefault(System.Action{CK.Monitoring.GrandOutput})"/>) and configured with default settings:
            only one one channel with its minimal filter sets to Debug with one file handler that writes .ckmon files in "<see cref="P:CK.Core.SystemActivityMonitor.RootLogPath"/>\GrandOutputDefault" directory.
            The <see cref="P:CK.Core.SystemActivityMonitor.RootLogPath"/> must be valid and if a GrandOutput.config file exists inside, it is loaded as the configuration.
            If it exists, it must be valid (otherwise an exception is thrown).
            Once loaded, the file is monitored and any change that occurs to it dynamically triggers a <see cref="M:CK.Monitoring.GrandOutput.SetConfiguration(CK.Monitoring.GrandOutputConfiguration,CK.Core.IActivityMonitor,System.Int32)"/> with the new file.
            </summary>
            <param name="monitor">An optional monitor.</param>
        </member>
        <member name="T:CK.Monitoring.GrandOutputClient">
            <summary>
            A GrandOutputClient is a <see cref="T:CK.Core.IActivityMonitorClient"/> that can only be obtained and registered
            through <see cref="M:CK.Monitoring.GrandOutput.Register(CK.Core.IActivityMonitor)"/>.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputClient.CK#Core#IActivityMonitorBoundClient#SetMonitor(CK.Core.Impl.IActivityMonitorImpl,System.Boolean)">
            <summary>
            forceBuggyRemove is not used here since this client is not lockable.
            </summary>
        </member>
        <member name="P:CK.Monitoring.GrandOutputClient.Central">
            <summary>
            Gets the <see cref="T:CK.Monitoring.GrandOutput"/> to which this <see cref="T:CK.Monitoring.GrandOutputClient"/> is bound.
            </summary>
        </member>
        <member name="T:CK.Monitoring.GrandOutputEventInfo">
            <summary>
            Captures a log data with the current <see cref="P:CK.Core.IActivityMonitor.Topic"/>.
            </summary>
        </member>
        <member name="F:CK.Monitoring.GrandOutputEventInfo.Entry">
            <summary>
            A unified, immutable, log data.
            </summary>
        </member>
        <member name="F:CK.Monitoring.GrandOutputEventInfo.Topic">
            <summary>
            The current topic of the monitor when the log occurred. 
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputEventInfo.#ctor(CK.Monitoring.IMulticastLogEntry,System.String)">
            <summary>
            Initializes a new <see cref="T:CK.Monitoring.GrandOutputEventInfo"/>.
            </summary>
            <param name="e">Log entry.</param>
            <param name="topic">Current topic.</param>
        </member>
        <member name="T:CK.Monitoring.GrandOutputHandlers.BinaryFile">
            <summary>
            Binary file handler.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.BinaryFile.#ctor(CK.Monitoring.GrandOutputHandlers.BinaryFileConfiguration)">
            <summary>
            Initializes a new <see cref="T:CK.Monitoring.GrandOutputHandlers.BinaryFileConfiguration"/> bound to its <see cref="T:CK.Monitoring.GrandOutputHandlers.BinaryFileConfiguration"/>.
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.BinaryFile.Initialize(CK.Core.IActivityMonitor)">
            <summary>
            Initialization of the handler: computes the path.
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.BinaryFile.Handle(CK.Monitoring.GrandOutputEventInfo,System.Boolean)">
            <summary>
            Writes a log entry (that can actually be a <see cref="T:CK.Monitoring.IMulticastLogEntry"/>).
            </summary>
            <param name="logEvent">The log entry.</param>
            <param name="parrallelCall">True if this is a parrallel call.</param>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.BinaryFile.Close(CK.Core.IActivityMonitor)">
            <summary>
            Closes the file if it is opened.
            </summary>
            <param name="m">The monitor to use to track activity.</param>
        </member>
        <member name="T:CK.Monitoring.GrandOutputHandlers.BinaryFileConfiguration">
            <summary>
            Configuration object for <see cref="T:CK.Monitoring.GrandOutputHandlers.BinaryFile"/>.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.BinaryFileConfiguration.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:CK.Monitoring.GrandOutputHandlers.BinaryFileConfiguration"/>.
            </summary>
            <param name="name">Name of this configuration.</param>
        </member>
        <member name="P:CK.Monitoring.GrandOutputHandlers.BinaryFileConfiguration.Path">
            <summary>
            Gets or sets the path of the file. When not rooted (see <see cref="M:System.IO.Path.IsPathRooted(System.String)"/>),
            it is a sub path in <see cref="P:CK.Core.SystemActivityMonitor.RootLogPath"/>.
            It defaults to null: it must be specified.
            </summary>
        </member>
        <member name="P:CK.Monitoring.GrandOutputHandlers.BinaryFileConfiguration.MaxCountPerFile">
            <summary>
            Gets or sets the maximal count of entries per file.
            Defaults to 20000.
            </summary>
        </member>
        <member name="P:CK.Monitoring.GrandOutputHandlers.BinaryFileConfiguration.FileWriteThrough">
            <summary>
            Gets or sets whether files will be opened with <see cref="F:System.IO.FileOptions.WriteThrough"/>.
            Defaults to false.
            </summary>
        </member>
        <member name="P:CK.Monitoring.GrandOutputHandlers.BinaryFileConfiguration.FileBufferSize">
            <summary>
            Gets or sets the buffer size used to write files.
            Defaults to 4096.
            </summary>
        </member>
        <member name="P:CK.Monitoring.GrandOutputHandlers.BinaryFileConfiguration.UseGzipCompression">
            <summary>
            Gets or sets whether to use Gzip compression after closing log files.
            Defaults to false.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.BinaryFileConfiguration.Initialize(CK.Core.IActivityMonitor,System.Xml.Linq.XElement)">
            <summary>
            Initializes (or reinitializes) this <see cref="T:CK.Monitoring.GrandOutputHandlers.BinaryFileConfiguration"/> from a <see cref="T:System.Xml.Linq.XElement"/>.
            </summary>
            <param name="monitor">Monitor to report errors or warnings.</param>
            <param name="xml">Source XML element.</param>
        </member>
        <member name="T:CK.Monitoring.GrandOutputHandlers.ChannelOption">
            <summary>
            Captures centralized information among the different <see cref="T:CK.Monitoring.GrandOutputHandlers.HandlerBase">Handlers</see> of a channel.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.ChannelOption.SetMinimalFilter(CK.Core.LogFilter)">
            <summary>
            Enables any handler to publish the minimal filter level it requires (if any).
            </summary>
            <param name="filter">Filter required by a <see cref="T:CK.Monitoring.GrandOutputHandlers.HandlerBase"/>.</param>
        </member>
        <member name="P:CK.Monitoring.GrandOutputHandlers.ChannelOption.CurrentMinimalFilter">
            <summary>
            Gets the minimal <see cref="T:CK.Core.LogFilter"/>.
            Since a handler can publish its minimal filter requirement, we can optimize the filtering levels on 
            monitors bound to a channel.
            </summary>
        </member>
        <member name="T:CK.Monitoring.GrandOutputHandlers.HandlerBase">
            <summary>
            Base class to handle of <see cref="T:CK.Monitoring.GrandOutputEventInfo"/>.
            Specialized handlers are configured by an associated <see cref="T:CK.Monitoring.GrandOutputHandlers.HandlerConfiguration"/> specialization.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.HandlerBase.#ctor(CK.RouteConfig.Impl.ActionCompositeConfiguration)">
            <summary>
            Internal constructor used by Sequence and Parallel.
            </summary>
            <param name="config">Parallel or sequence configuration.</param>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.HandlerBase.#ctor(CK.Monitoring.GrandOutputHandlers.HandlerConfiguration)">
            <summary>
            Base constructor bound to base configuration object.
            </summary>
            <param name="config">The configuration object.</param>
        </member>
        <member name="P:CK.Monitoring.GrandOutputHandlers.HandlerBase.Name">
            <summary>
            Gets the name of this handler. It is the name of its configuration.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.HandlerBase.Initialize(CK.Core.IActivityMonitor)">
            <summary>
            Initializes this handler. 
            This is called once for all the configured sink at the start of a new 
            configuration, before the first call to <see cref="M:CK.Monitoring.GrandOutputHandlers.HandlerBase.Handle(CK.Monitoring.GrandOutputEventInfo,System.Boolean)"/>.
            Default implementation does nothing.
            </summary>
            <param name="monitor">The monitor that tracks configuration process.</param>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.HandlerBase.CollectChannelOption(CK.Monitoring.GrandOutputHandlers.ChannelOption)">
            <summary>
            Enables this handler to interact with any channel to which it belongs. 
            This is called after <see cref="M:CK.Monitoring.GrandOutputHandlers.HandlerBase.Initialize(CK.Core.IActivityMonitor)"/> and for each channel where this handler appears, before the first call to <see cref="M:CK.Monitoring.GrandOutputHandlers.HandlerBase.Handle(CK.Monitoring.GrandOutputEventInfo,System.Boolean)"/>.
            Default implementation must be called: sets the minimal filter on the option if the <see cref="T:CK.Monitoring.GrandOutputHandlers.HandlerConfiguration"/> defines it.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.HandlerBase.Handle(CK.Monitoring.GrandOutputEventInfo,System.Boolean)">
            <summary>
            Handles a <see cref="T:CK.Monitoring.GrandOutputEventInfo"/>.
            </summary>
            <param name="logEvent">Event to handle.</param>
            <param name="parrallelCall">True when this method is called in parallel with other handlers.</param>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.HandlerBase.Close(CK.Core.IActivityMonitor)">
            <summary>
            Closes this handler.
            This is called when a reconfiguration occurs after all
            events have been <see cref="M:CK.Monitoring.GrandOutputHandlers.HandlerBase.Handle(CK.Monitoring.GrandOutputEventInfo,System.Boolean)"/>d.
            Default implementation does nothing.
            </summary>
            <param name="monitor">The monitor that tracks configuration process.</param>
        </member>
        <member name="T:CK.Monitoring.GrandOutputHandlers.HandlerConfiguration">
            <summary>
            Base class for handler configuration.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.HandlerConfiguration.#ctor(System.String)">
            <summary>
            Initializes a new handler configuration.
            </summary>
            <param name="name">The configuration name.</param>
        </member>
        <member name="P:CK.Monitoring.GrandOutputHandlers.HandlerConfiguration.MinimalFilter">
            <summary>
            Gets or sets the minimal filter for this handler.
            Defaults to <see cref="F:CK.Core.LogFilter.Undefined"/>: unless specified, the handler will not 
            participate to <see cref="P:CK.Core.IActivityMonitor.ActualFilter"/> resolution of monitors that eventually 
            are handled by this handler.See remarks. 
            </summary>
            <remarks>
            <para>
            This is NOT a filter: this is the minimal filter that guaranties that, at least, the specified 
            levels will reach this handler.
            </para>
            <para>
            A concrete handler can, if needed, define a true filter: it is its business to retain or forget 
            what it wants.
            </para>
            </remarks>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.HandlerConfiguration.Initialize(CK.Core.IActivityMonitor,System.Xml.Linq.XElement)">
            <summary>
            Must initializes this configuration object with its specific data from an xml element.
            </summary>
            <param name="m">Monitor to use.</param>
            <param name="xml">The xml element.</param>
        </member>
        <member name="T:CK.Monitoring.GrandOutputHandlers.HandlerTypeAttribute">
            <summary>
            Simple attribute that binds a <see cref="T:CK.Monitoring.GrandOutputHandlers.HandlerConfiguration"/> to the actual <see cref="T:CK.Monitoring.GrandOutputHandlers.HandlerBase"/> that will actually do the job.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.HandlerTypeAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new <see cref="T:CK.Monitoring.GrandOutputHandlers.HandlerTypeAttribute"/> with a type that must be a <see cref="T:CK.Monitoring.GrandOutputHandlers.HandlerBase"/> specialization.
            </summary>
            <param name="handlerType"></param>
        </member>
        <member name="F:CK.Monitoring.GrandOutputHandlers.HandlerTypeAttribute.HandlerType">
            <summary>
            Gets the type of the associated <see cref="T:CK.Monitoring.GrandOutputHandlers.HandlerBase"/>.
            </summary>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.ParallelHandler.Handle(CK.Monitoring.GrandOutputEventInfo,System.Boolean)">
            <summary>
            Handles a <see cref="T:CK.Monitoring.GrandOutputEventInfo"/> by calling each
            child's handler in parallel.
            </summary>
            <param name="logEvent">Event to handle.</param>
            <param name="parrallelCall">True if this is called in parallel.</param>
        </member>
        <member name="M:CK.Monitoring.GrandOutputHandlers.SequenceHandler.Handle(CK.Monitoring.GrandOutputEventInfo,System.Boolean)">
            <summary>
            Handles a <see cref="T:CK.Monitoring.GrandOutputEventInfo"/> by calling each
            child's handle in sequence.
            </summary>
            <param name="logEvent">Event to handle.</param>
            <param name="parrallelCall">True if this is called in parallel.</param>
        </member>
        <member name="T:CK.Monitoring.IGrandOutputBridgeTarget">
            <summary>
            External entry point for cross application domain bridge.
            </summary>
        </member>
        <member name="T:CK.Monitoring.IGrandOutputDispatcherStrategy">
            <summary>
            Defines a strategy to manage dispatching log events overload and idle time management.
            </summary>
        </member>
        <member name="M:CK.Monitoring.IGrandOutputDispatcherStrategy.Initialize(System.Func{System.Int32},System.Threading.Thread,System.Func{System.Int32,System.Int32}@)">
            <summary>
            Called once and only once during <see cref="T:CK.Monitoring.GrandOutput"/> initialization.
            </summary>
            <param name="instantLoad">Gets the number of items waiting to be processed.</param>
            <param name="dispatcher">The dispatcher thread.</param>
            <param name="idleManager">Function that returns the time in milliseconds to wait for a given idle count.</param>
        </member>
        <member name="M:CK.Monitoring.IGrandOutputDispatcherStrategy.IsOpened(System.Int32@)">
            <summary>
            Called concurrently for each new event to handle: this must be fully thread-safe and as much efficient as it could be 
            since this is called on the monitored side.
            </summary>
            <returns>True to accept the event, false to reject it.</returns>
        </member>
        <member name="P:CK.Monitoring.IGrandOutputDispatcherStrategy.IgnoredConcurrentCallCount">
            <summary>
            Gets the count of concurrent sampling: each time <see cref="M:CK.Monitoring.IGrandOutputDispatcherStrategy.IsOpened(System.Int32@)"/> has been
            called while it was already called by another thread.
            </summary>
        </member>
        <member name="T:CK.Monitoring.IGrandOutputSink">
            <summary>
            Defines a sink that can be registered onto a <see cref="T:CK.Monitoring.GrandOutput"/>
            to intercept any log event. It is also supported by <see cref="T:CK.Monitoring.GrandOutputHandlers.HandlerBase"/>.
            </summary>
        </member>
        <member name="M:CK.Monitoring.IGrandOutputSink.Handle(CK.Monitoring.GrandOutputEventInfo,System.Boolean)">
            <summary>
            This is initially called non concurrently from a dispatcher background thread:
            implementations do not need any synchronization mechanism by default except when <paramref name="parrallelCall"/> is true.
            </summary>
            <param name="logEvent">The log event.</param>
            <param name="parrallelCall">True when this method is called in parallel with other sinks.</param>
        </member>
        <member name="T:CK.Monitoring.ILogEntry">
            <summary>
            Unified interface for log entries whatever their <see cref="P:CK.Monitoring.ILogEntry.LogType"/> is.
            All log entries can be exposed through this "rich" interface.
            </summary>
        </member>
        <member name="P:CK.Monitoring.ILogEntry.LogType">
            <summary>
            Gets the type of the log entry.
            </summary>
        </member>
        <member name="P:CK.Monitoring.ILogEntry.LogLevel">
            <summary>
            Get the log level (between LogLevel.Trace and LogLevel.Fatal).
            This is available whatever <see cref="P:CK.Monitoring.ILogEntry.LogType"/> is.
            </summary>
        </member>
        <member name="P:CK.Monitoring.ILogEntry.Text">
            <summary>
            Gets the log text.
            Null when when <see cref="P:CK.Monitoring.ILogEntry.LogType"/> is <see cref="F:CK.Monitoring.LogEntryType.CloseGroup"/>.
            </summary>
        </member>
        <member name="P:CK.Monitoring.ILogEntry.Tags">
            <summary>
            Gets the tags for this entry.
            Always equals to <see cref="F:CK.Core.ActivityMonitor.Tags.Empty"/> when <see cref="P:CK.Monitoring.ILogEntry.LogType"/> is <see cref="F:CK.Monitoring.LogEntryType.CloseGroup"/>.
            </summary>
        </member>
        <member name="P:CK.Monitoring.ILogEntry.LogTime">
            <summary>
            Gets the log time.
            This is available whatever <see cref="P:CK.Monitoring.ILogEntry.LogType"/> is.
            </summary>
        </member>
        <member name="P:CK.Monitoring.ILogEntry.Exception">
            <summary>
            Gets the exception data if any (can be not null only when <see cref="P:CK.Monitoring.ILogEntry.LogType"/> is <see cref="F:CK.Monitoring.LogEntryType.OpenGroup"/>: exceptions are exclusively carried by groups).
            </summary>
        </member>
        <member name="P:CK.Monitoring.ILogEntry.FileName">
            <summary>
            Gets the file name of the source code that emitted the log.
            Null when <see cref="P:CK.Monitoring.ILogEntry.LogType"/> is <see cref="F:CK.Monitoring.LogEntryType.CloseGroup"/>.
            </summary>
        </member>
        <member name="P:CK.Monitoring.ILogEntry.LineNumber">
            <summary>
            Gets the line number in the source code <see cref="P:CK.Monitoring.ILogEntry.FileName"/> that emitted the log.
            0 when <see cref="P:CK.Monitoring.ILogEntry.LogType"/> is <see cref="F:CK.Monitoring.LogEntryType.CloseGroup"/>.
            </summary>
        </member>
        <member name="P:CK.Monitoring.ILogEntry.Conclusions">
            <summary>
            Gets any group conclusion. 
            Always null except of course when <see cref="P:CK.Monitoring.ILogEntry.LogType"/> is <see cref="F:CK.Monitoring.LogEntryType.CloseGroup"/>.
            </summary>
        </member>
        <member name="M:CK.Monitoring.ILogEntry.WriteLogEntry(System.IO.BinaryWriter)">
            <summary>
            Writes the entry in a <see cref="T:System.IO.BinaryWriter"/>.
            Use <see cref="M:CK.Monitoring.LogEntry.Read(System.IO.BinaryReader,System.Int32,System.Boolean@)"/> to read it back.
            </summary>
            <param name="w">The binary writer.</param>
        </member>
        <member name="T:CK.Monitoring.Impl.BufferingChannel">
            <summary>
            This kind of channel is bound to a <see cref="T:CK.Monitoring.GrandOutputClient"/>. It is returned by <see cref="M:CK.Monitoring.GrandOutput.ObtainChannel(System.String)"/>
            when a configuration is being applied.
            </summary>
        </member>
        <member name="M:CK.Monitoring.Impl.BufferingChannel.EnsureActive">
            <summary>
            Can be called either from GrandOutput.OnConfigurationClosing or from GrandOutput.ObtainChannel when the FlushLock is acquired.
            This sets the CountdownEvent to 1. 
            </summary>
        </member>
        <member name="M:CK.Monitoring.Impl.BufferingChannel.FlushBuffer(System.Func{System.String,CK.Monitoring.IChannel})">
            <summary>
            Flushes all buffered GrandOutputEventInfo into appropriate channels.
            It is called by the GrandOutput.OnConfigurationReady method to transfer buffered log events
            into the appropriate new routes.
            This is the only step during which a lock blocks GrandOutput.ObtainChannel calls.
            </summary>
            <param name="newChannels">Function that knows how to return the channel to uses based on the topic string.</param>
        </member>
        <member name="T:CK.Monitoring.Impl.ChannelHost">
            <summary>
            Actual specialization of the generic <see cref="T:CK.RouteConfig.ConfiguredRouteHost`2"/> with <see cref="T:CK.Monitoring.GrandOutputHandlers.HandlerBase"/> and <see cref="T:CK.Monitoring.IChannel"/>.
            </summary>
        </member>
        <member name="T:CK.Monitoring.Impl.EventDispatcherBasicStrategy">
            <summary>
            Implements a basic strategy that handles activities logging overloads.
            </summary>
        </member>
        <member name="M:CK.Monitoring.Impl.EventDispatcherBasicStrategy.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new basic strategy. 
            Default parameters should be used.
            </summary>
            <param name="maxCapacity">Maximum capacity.</param>
            <param name="reenableCapacity">Defaults to 4/5 of the maximum capacity.</param>
            <param name="samplingCount">Actual check of the queue count is done by default each 1/10 of the maximum capacity.</param>
        </member>
        <member name="P:CK.Monitoring.Impl.EventDispatcherBasicStrategy.IgnoredConcurrentCallCount">
            <summary>
            Gets the count of concurrent sampling (when this strategy has been called while it was already called by another thread).
            </summary>
        </member>
        <member name="T:CK.Monitoring.IChannel">
            <summary>
            Abstraction of a Channel: it knows how to <see cref="M:CK.Monitoring.IChannel.Handle(CK.Monitoring.GrandOutputEventInfo,System.Boolean)"/> log events.
            </summary>
        </member>
        <member name="M:CK.Monitoring.IChannel.Initialize">
            <summary>
            Called once the channel is ready to <see cref="M:CK.Monitoring.IChannel.Handle(CK.Monitoring.GrandOutputEventInfo,System.Boolean)"/> events (but before the new configuration is actually applied).
            </summary>
        </member>
        <member name="P:CK.Monitoring.IChannel.MinimalFilter">
            <summary>
            Gets the minimal log level that this channel expects. 
            Should default to <see cref="F:CK.Core.LogLevelFilter.None"/>.
            </summary>
        </member>
        <member name="M:CK.Monitoring.IChannel.PreHandleLock">
            <summary>
            Locks the channel: a call to <see cref="M:CK.Monitoring.IChannel.Handle(CK.Monitoring.GrandOutputEventInfo,System.Boolean)"/> is pending.
            This is required to avoid a race condition between Channel is obtained by a GrandOutputClient 
            and the call to Handle.
            </summary>
        </member>
        <member name="M:CK.Monitoring.IChannel.CancelPreHandleLock">
            <summary>
            Cancels a previous call to <see cref="M:CK.Monitoring.IChannel.PreHandleLock"/>.
            This is used when the Channel to use must be changed while being obtained by a GrandOutputClient. 
            </summary>
        </member>
        <member name="M:CK.Monitoring.IChannel.Handle(CK.Monitoring.GrandOutputEventInfo,System.Boolean)">
            <summary>
            Handles one event.
            This is called by GrandOutputClients that are bound to this channel.
            The lock previously obtained by a call to PreHandleLock is released.
            </summary>
            <param name="e">Event to handle.</param>
            <param name="sendToCommonSink">
            True when the event must be sent to the common sink. 
            False when the event has been buffered: it has already been sent to the common sink.
            </param>
        </member>
        <member name="T:CK.Monitoring.IMulticastLogEntry">
            <summary>
            Unified interface for multi-cast log entries whatever their <see cref="P:CK.Monitoring.ILogEntry.LogType"/> or their source <see cref="P:CK.Monitoring.IMulticastLogInfo.MonitorId"/> is.
            All log entries can be exposed through this "rich" interface.
            </summary>
        </member>
        <member name="P:CK.Monitoring.IMulticastLogEntry.GroupDepth">
            <summary>
            Gets the depth of the entry in the source <see cref="P:CK.Monitoring.IMulticastLogInfo.MonitorId"/>.
            This is always available (whatever the <see cref="P:CK.Monitoring.ILogEntry.LogType">LogType</see> is <see cref="F:CK.Monitoring.LogEntryType.OpenGroup"/>, <see cref="F:CK.Monitoring.LogEntryType.CloseGroup"/>,
            or <see cref="F:CK.Monitoring.LogEntryType.Line"/>).
            </summary>
        </member>
        <member name="M:CK.Monitoring.IMulticastLogEntry.CreateUnicastLogEntry">
            <summary>
            Creates a unicast entry from this multi-cast one.
            The <see cref="P:CK.Monitoring.IMulticastLogInfo.MonitorId"/> and <see cref="P:CK.Monitoring.IMulticastLogEntry.GroupDepth"/> are lost (but less memory is used).
            </summary>
        </member>
        <member name="T:CK.Monitoring.IMulticastLogInfo">
            <summary>
            Information required by a <see cref="T:CK.Monitoring.IMulticastLogEntry"/>.
            </summary>
        </member>
        <member name="P:CK.Monitoring.IMulticastLogInfo.MonitorId">
            <summary>
            Gets the monitor identifier.
            </summary>
        </member>
        <member name="P:CK.Monitoring.IMulticastLogInfo.GroupDepth">
            <summary>
            Gets the depth of the entry in the source <see cref="P:CK.Monitoring.IMulticastLogInfo.MonitorId"/>.
            </summary>
        </member>
        <member name="P:CK.Monitoring.IMulticastLogInfo.PreviousEntryType">
            <summary>
            Gets the previous entry type. <see cref="F:CK.Monitoring.LogEntryType.None"/> when unknown.
            </summary>
        </member>
        <member name="P:CK.Monitoring.IMulticastLogInfo.PreviousLogTime">
            <summary>
            Gets the previous log time. <see cref="F:CK.Core.DateTimeStamp.Unknown"/> when unknown.
            </summary>
        </member>
        <member name="T:CK.Monitoring.LogEntryType">
            <summary>
            Type of a <see cref="T:CK.Monitoring.ILogEntry"/>.
            </summary>
        </member>
        <member name="F:CK.Monitoring.LogEntryType.None">
            <summary>
            Non applicable.
            </summary>
        </member>
        <member name="F:CK.Monitoring.LogEntryType.Line">
            <summary>
            A standard log entry.
            Except <see cref="P:CK.Monitoring.ILogEntry.Conclusions"/> (reserved to <see cref="F:CK.Monitoring.LogEntryType.CloseGroup"/>), all other properties of the <see cref="T:CK.Monitoring.ILogEntry"/> may be set.
            </summary>
        </member>
        <member name="F:CK.Monitoring.LogEntryType.OpenGroup">
            <summary>
            Group is opened.
            Except <see cref="P:CK.Monitoring.ILogEntry.Conclusions"/> (reserved to <see cref="F:CK.Monitoring.LogEntryType.CloseGroup"/>), all other properties of the <see cref="T:CK.Monitoring.ILogEntry"/> may be set.
            </summary>
        </member>
        <member name="F:CK.Monitoring.LogEntryType.CloseGroup">
            <summary>
            Group is closed. 
            Note that the only available information are <see cref="P:CK.Monitoring.ILogEntry.Conclusions"/>, <see cref="P:CK.Monitoring.ILogEntry.LogLevel"/> and <see cref="P:CK.Monitoring.ILogEntry.LogTime"/>.
            All other properties are set to their default: <see cref="P:CK.Monitoring.ILogEntry.Text"/> for instance is null.
            </summary>
        </member>
        <member name="T:CK.Monitoring.MonitorBinaryFileOutput">
            <summary>
            Helper class that encapsulates temporary stream and final renaming for log entries streams.
            This currently handles only the maximum count of entries per file but this may be extended with options like "SubFolderMode" that can be based 
            on current time (to group logs inside timed intermediate folders like one per day: 2014/01/12 or 2014-01/12, etc.). 
            </summary>
        </member>
        <member name="M:CK.Monitoring.MonitorBinaryFileOutput.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>
            Initializes a new file for <see cref="T:CK.Monitoring.IMulticastLogEntry"/>: the final file name is based on <see cref="F:CK.Core.FileUtil.FileNameUniqueTimeUtcFormat"/> with a ".ckmon" extension.
            You must call <see cref="M:CK.Monitoring.MonitorBinaryFileOutput.Initialize(CK.Core.IActivityMonitor)"/> before actually using this object.
            </summary>
            <param name="configuredPath">The path: it can be absolute and when relative, it will be under <see cref="P:CK.Core.SystemActivityMonitor.RootLogPath"/> (that must be set).</param>
            <param name="maxCountPerFile">Maximum number of entries per file. Must be greater than 1.</param>
            <param name="useGzipCompression">True to gzip the file.</param>
        </member>
        <member name="M:CK.Monitoring.MonitorBinaryFileOutput.#ctor(System.String,System.Guid,System.Int32,System.Boolean)">
            <summary>
            Initializes a new file for <see cref="T:CK.Monitoring.ILogEntry"/> issued from a specific monitor: the final file name is 
            based on <see cref="F:CK.Core.FileUtil.FileNameUniqueTimeUtcFormat"/> with a "-{XXX...XXX}.ckmon" suffix where {XXX...XXX} is the unique identifier (Guid with the B format - 32 digits separated by 
            hyphens, enclosed in braces) of the monitor.
            You must call <see cref="M:CK.Monitoring.MonitorBinaryFileOutput.Initialize(CK.Core.IActivityMonitor)"/> before actually using this object.
            </summary>
            <param name="configuredPath">The path. Can be absolute. When relative, it will be under <see cref="P:CK.Core.SystemActivityMonitor.RootLogPath"/> that must be set.</param>
            <param name="monitorId">Monitor identifier.</param>
            <param name="maxCountPerFile">Maximum number of entries per file. Must be greater than 1.</param>
            <param name="useGzipCompression">True to gzip the file.</param>
        </member>
        <member name="M:CK.Monitoring.MonitorBinaryFileOutput.ComputeBasePath(CK.Core.IActivityMonitor)">
            <summary>
            Computes the root path.
            </summary>
            <param name="m">A monitor (must not be null).</param>
            <returns>The final path to use (ends with '\'). Null if unable to compute the path.</returns>
        </member>
        <member name="P:CK.Monitoring.MonitorBinaryFileOutput.MaxCountPerFile">
            <summary>
            Gets the maximum number of entries per file.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MonitorBinaryFileOutput.FileWriteThrough">
            <summary>
            Gets or sets whether files will be opened with <see cref="F:System.IO.FileOptions.WriteThrough"/>.
            Defaults to false.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MonitorBinaryFileOutput.FileBufferSize">
            <summary>
            Gets or sets the buffer size used to write files.
            Defaults to 4096.
            </summary>
        </member>
        <member name="M:CK.Monitoring.MonitorBinaryFileOutput.Initialize(CK.Core.IActivityMonitor)">
            <summary>
            Checks whether this <see cref="T:CK.Monitoring.MonitorBinaryFileOutput"/> is valid: its base path is successfully created.
            Can be called multiple times.
            </summary>
            <param name="monitor">Required monitor.</param>
        </member>
        <member name="P:CK.Monitoring.MonitorBinaryFileOutput.IsOpened">
            <summary>
            Gets whether this file is currently opened.
            </summary>
        </member>
        <member name="M:CK.Monitoring.MonitorBinaryFileOutput.Close">
            <summary>
            Closes the file if it is currently opened.
            Does nothing otherwise.
            </summary>
        </member>
        <member name="M:CK.Monitoring.MonitorBinaryFileOutput.Write(CK.Monitoring.ILogEntry)">
            <summary>
            Writes a log entry (that can actually be a <see cref="T:CK.Monitoring.IMulticastLogEntry"/>).
            </summary>
            <param name="e">The log entry.</param>
        </member>
        <member name="M:CK.Monitoring.MonitorBinaryFileOutput.UnicastWrite(CK.Core.ActivityMonitorLogData,CK.Monitoring.IMulticastLogInfo)">
            <summary>
            Writes a line entry as a uni-cast compact entry or as a multi-cast one if needed.
            </summary>
            <param name="data">The log line.</param>
            <param name="adapter">Multi-cast information to be able to write multi-cast entry when needed.</param>
        </member>
        <member name="M:CK.Monitoring.MonitorBinaryFileOutput.UnicastWriteOpenGroup(CK.Core.IActivityLogGroup,CK.Monitoring.IMulticastLogInfo)">
            <summary>
            Writes a group opening entry as a uni-cast compact entry or as a multi-cast one if needed.
            </summary>
            <param name="g">The group line.</param>
            <param name="adapter">Multi-cast information to be able to write multi-cast entry when needed.</param>
        </member>
        <member name="M:CK.Monitoring.MonitorBinaryFileOutput.UnicastWriteCloseGroup(CK.Core.IActivityLogGroup,System.Collections.Generic.IReadOnlyList{CK.Core.ActivityLogGroupConclusion},CK.Monitoring.IMulticastLogInfo)">
            <summary>
            Writes a group closing entry as a uni-cast compact entry or as a multi-cast one if needed.
            </summary>
            <param name="g">The group.</param>
            <param name="conclusions">Group's conclusions.</param>
            <param name="adapter">Multi-cast information to be able to write multi-cast entry when needed.</param>
        </member>
        <member name="M:CK.Monitoring.MonitorBinaryFileOutput.Dispose">
            <summary>
            Simply calls <see cref="M:CK.Monitoring.MonitorBinaryFileOutput.Close"/>.
            </summary>
        </member>
        <member name="T:CK.Monitoring.CKMonWriterClient">
            <summary>
            This client writes .ckmon files for one monitor.
            To close output file, simply <see cref="M:CK.Core.IActivityMonitorOutput.UnregisterClient(CK.Core.IActivityMonitorClient)">unregister</see> this client.
            </summary>
        </member>
        <member name="M:CK.Monitoring.CKMonWriterClient.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Monitoring.CKMonWriterClient"/> that can be registered to write uncompressed .ckmon file for this monitor.
            </summary>
            <param name="path">The path. Can be absolute. When relative, it will be under <see cref="P:CK.Core.SystemActivityMonitor.RootLogPath"/> that must be set.</param>
            <param name="maxCountPerFile">Maximum number of entries per file. Must be greater than 1.</param>
        </member>
        <member name="M:CK.Monitoring.CKMonWriterClient.#ctor(System.String,System.Int32,CK.Core.LogFilter,System.Boolean)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Monitoring.CKMonWriterClient"/> that can be registered to write compressed or uncompressed .ckmon file for this monitor.
            </summary>
            <param name="path">The path. Can be absolute. When relative, it will be under <see cref="P:CK.Core.SystemActivityMonitor.RootLogPath"/> that must be set.</param>
            <param name="maxCountPerFile">Maximum number of entries per file. Must be greater than 1.</param>
            <param name="minimalFilter">Minimal filter for this client.</param>
            <param name="useGzipCompression">Whether to output compressed .ckmon files. Defaults to false (do not compress).</param>
        </member>
        <member name="P:CK.Monitoring.CKMonWriterClient.MinimalFilter">
            <summary>
            Gets the minimal filter set by the constructor.
            </summary>
        </member>
        <member name="M:CK.Monitoring.CKMonWriterClient.Open">
            <summary>
            Opens this writer if it is not already opened.
            </summary>
            <returns>True on success, false otherwise.</returns>
        </member>
        <member name="M:CK.Monitoring.CKMonWriterClient.Close">
            <summary>
            Closes this writer if it <see cref="P:CK.Monitoring.CKMonWriterClient.IsOpened"/>.
            It can be re-<see cref="M:CK.Monitoring.CKMonWriterClient.Open"/>ed later.
            </summary>
        </member>
        <member name="P:CK.Monitoring.CKMonWriterClient.IsOpened">
            <summary>
            Gets whether this writer is opened.
            </summary>
        </member>
        <member name="T:CK.Monitoring.LogEntry">
            <summary>
            Encapsulates <see cref="T:CK.Monitoring.ILogEntry"/> concrete objects manipulation.
            </summary>
        </member>
        <member name="M:CK.Monitoring.LogEntry.CreateLog(System.String,CK.Core.DateTimeStamp,CK.Core.LogLevel,System.String,System.Int32,CK.Core.CKTrait,CK.Core.CKExceptionData)">
            <summary>
            Creates a <see cref="T:CK.Monitoring.ILogEntry"/> for a line.
            </summary>
            <param name="text">Text of the log entry.</param>
            <param name="t">Time stamp of the log entry.</param>
            <param name="level">Log level of the log entry.</param>
            <param name="fileName">Source file name of the log entry</param>
            <param name="lineNumber">Source line number of the log entry</param>
            <param name="tags">Tags of the log entry</param>
            <param name="ex">Exception of the log entry.</param>
            <returns>A log entry object.</returns>
        </member>
        <member name="M:CK.Monitoring.LogEntry.CreateOpenGroup(System.String,CK.Core.DateTimeStamp,CK.Core.LogLevel,System.String,System.Int32,CK.Core.CKTrait,CK.Core.CKExceptionData)">
            <summary>
            Creates a <see cref="T:CK.Monitoring.ILogEntry"/> for an opened group.
            </summary>
            <param name="text">Text of the log entry.</param>
            <param name="t">Time stamp of the log entry.</param>
            <param name="level">Log level of the log entry.</param>
            <param name="fileName">Source file name of the log entry</param>
            <param name="lineNumber">Source line number of the log entry</param>
            <param name="tags">Tags of the log entry</param>
            <param name="ex">Exception of the log entry.</param>
            <returns>A log entry object.</returns>
        </member>
        <member name="M:CK.Monitoring.LogEntry.CreateCloseGroup(CK.Core.DateTimeStamp,CK.Core.LogLevel,System.Collections.Generic.IReadOnlyList{CK.Core.ActivityLogGroupConclusion})">
            <summary>
            Creates a <see cref="T:CK.Monitoring.ILogEntry"/> for the closing of a group.
            </summary>
            <param name="t">Time stamp of the log entry.</param>
            <param name="level">Log level of the log entry.</param>
            <param name="c">Group conclusions.</param>
            <returns>A log entry object.</returns>
        </member>
        <member name="M:CK.Monitoring.LogEntry.CreateMulticastLog(System.Guid,CK.Monitoring.LogEntryType,CK.Core.DateTimeStamp,System.Int32,System.String,CK.Core.DateTimeStamp,CK.Core.LogLevel,System.String,System.Int32,CK.Core.CKTrait,CK.Core.CKExceptionData)">
            <summary>
            Creates a <see cref="T:CK.Monitoring.ILogEntry"/> for a line.
            </summary>
            <param name="monitorId">Identifier of the monitor.</param>
            <param name="previousEntryType">Log type of the previous entry in the monitor..</param>
            <param name="previousLogTime">Time stamp of the previous entry in the monitor.</param>
            <param name="depth">Depth of the line (number of opened groups above).</param>
            <param name="text">Text of the log entry.</param>
            <param name="t">Time stamp of the log entry.</param>
            <param name="level">Log level of the log entry.</param>
            <param name="fileName">Source file name of the log entry</param>
            <param name="lineNumber">Source line number of the log entry</param>
            <param name="tags">Tags of the log entry</param>
            <param name="ex">Exception of the log entry.</param>
            <returns>A log entry object.</returns>
        </member>
        <member name="M:CK.Monitoring.LogEntry.CreateMulticastOpenGroup(System.Guid,CK.Monitoring.LogEntryType,CK.Core.DateTimeStamp,System.Int32,System.String,CK.Core.DateTimeStamp,CK.Core.LogLevel,System.String,System.Int32,CK.Core.CKTrait,CK.Core.CKExceptionData)">
            <summary>
            Creates a <see cref="T:CK.Monitoring.ILogEntry"/> for an opened group.
            </summary>
            <param name="monitorId">Identifier of the monitor.</param>
            <param name="previousEntryType">Log type of the previous entry in the monitor..</param>
            <param name="previousLogTime">Time stamp of the previous entry in the monitor.</param>
            <param name="depth">Depth of the line (number of opened groups above).</param>
            <param name="text">Text of the log entry.</param>
            <param name="t">Time stamp of the log entry.</param>
            <param name="level">Log level of the log entry.</param>
            <param name="fileName">Source file name of the log entry</param>
            <param name="lineNumber">Source line number of the log entry</param>
            <param name="tags">Tags of the log entry</param>
            <param name="ex">Exception of the log entry.</param>
            <returns>A log entry object.</returns>
        </member>
        <member name="M:CK.Monitoring.LogEntry.CreateMulticastCloseGroup(System.Guid,CK.Monitoring.LogEntryType,CK.Core.DateTimeStamp,System.Int32,CK.Core.DateTimeStamp,CK.Core.LogLevel,System.Collections.Generic.IReadOnlyList{CK.Core.ActivityLogGroupConclusion})">
            <summary>
            Creates a <see cref="T:CK.Monitoring.ILogEntry"/> for the closing of a group.
            </summary>
            <param name="monitorId">Identifier of the monitor.</param>
            <param name="previousEntryType">Log type of the previous entry in the monitor..</param>
            <param name="previousLogTime">Time stamp of the previous entry in the monitor.</param>
            <param name="depth">Depth of the line (number of opened groups above).</param>
            <param name="t">Time stamp of the log entry.</param>
            <param name="level">Log level of the log entry.</param>
            <param name="c">Group conclusions.</param>
            <returns>A log entry object.</returns>
        </member>
        <member name="M:CK.Monitoring.LogEntry.WriteLog(System.IO.BinaryWriter,System.Guid,CK.Monitoring.LogEntryType,CK.Core.DateTimeStamp,System.Int32,System.Boolean,CK.Core.LogLevel,CK.Core.DateTimeStamp,System.String,CK.Core.CKTrait,CK.Core.CKExceptionData,System.String,System.Int32)">
            <summary>
            Binary writes a multicast log entry.
            </summary>
            <param name="w">Binary writer to use.</param>
            <param name="monitorId">Identifier of the monitor.</param>
            <param name="previousEntryType">Log type of the previous entry in the monitor..</param>
            <param name="previousLogTime">Time stamp of the previous entry in the monitor.</param>
            <param name="depth">Depth of the line (number of opened groups above).</param>
            <param name="isOpenGroup">True if this the opening of a group. False for a line.</param>
            <param name="text">Text of the log entry.</param>
            <param name="level">Log level of the log entry.</param>
            <param name="logTime">Time stamp of the log entry.</param>
            <param name="tags">Tags of the log entry</param>
            <param name="ex">Exception of the log entry.</param>
            <param name="fileName">Source file name of the log entry</param>
            <param name="lineNumber">Source line number of the log entry</param>
        </member>
        <member name="M:CK.Monitoring.LogEntry.WriteLog(System.IO.BinaryWriter,System.Boolean,CK.Core.LogLevel,CK.Core.DateTimeStamp,System.String,CK.Core.CKTrait,CK.Core.CKExceptionData,System.String,System.Int32)">
            <summary>
            Binary writes a log entry.
            </summary>
            <param name="w">Binary writer to use.</param>
            <param name="isOpenGroup">True if this the opening of a group. False for a line.</param>
            <param name="level">Log level of the log entry.</param>
            <param name="text">Text of the log entry.</param>
            <param name="logTime">Time stamp of the log entry.</param>
            <param name="tags">Tags of the log entry</param>
            <param name="ex">Exception of the log entry.</param>
            <param name="fileName">Source file name of the log entry</param>
            <param name="lineNumber">Source line number of the log entry</param>
        </member>
        <member name="M:CK.Monitoring.LogEntry.WriteCloseGroup(System.IO.BinaryWriter,CK.Core.LogLevel,CK.Core.DateTimeStamp,System.Collections.Generic.IReadOnlyList{CK.Core.ActivityLogGroupConclusion})">
            <summary>
            Binary writes a closing entry.
            </summary>
            <param name="w">Binary writer to use.</param>
            <param name="level">Log level of the log entry.</param>
            <param name="closeTime">Time stamp of the group closing.</param>
            <param name="conclusions">Group conclusions.</param>
        </member>
        <member name="M:CK.Monitoring.LogEntry.WriteCloseGroup(System.IO.BinaryWriter,System.Guid,CK.Monitoring.LogEntryType,CK.Core.DateTimeStamp,System.Int32,CK.Core.LogLevel,CK.Core.DateTimeStamp,System.Collections.Generic.IReadOnlyList{CK.Core.ActivityLogGroupConclusion})">
            <summary>
            Binary writes a multicast closing entry.
            </summary>
            <param name="w">Binary writer to use.</param>
            <param name="monitorId">Identifier of the monitor.</param>
            <param name="previousEntryType">Log type of the previous entry in the monitor..</param>
            <param name="previousLogTime">Time stamp of the previous entry in the monitor.</param>
            <param name="depth">Depth of the group (number of opened groups above).</param>
            <param name="level">Log level of the log entry.</param>
            <param name="closeTime">Time stamp of the group closing.</param>
            <param name="conclusions">Group conclusions.</param>
        </member>
        <member name="M:CK.Monitoring.LogEntry.Read(System.IO.BinaryReader,System.Int32,System.Boolean@)">
            <summary>
            Reads a <see cref="T:CK.Monitoring.ILogEntry"/> from the binary reader that can be a <see cref="T:CK.Monitoring.IMulticastLogEntry"/>.
            If the first read byte is 0, read stops and null is returned.
            The 0 byte is the "end marker" that <see cref="M:CK.Monitoring.CKMonWriterClient.Close"/> write, but this
            method can read non zero-terminated streams (it catches an EndOfStreamException when reading the first byte and handles it silently).
            This method can throw any type of exception (<see cref="T:System.IO.EndOfStreamException"/> or <see cref="T:System.IO.InvalidDataException"/> for instance) that
            must be handled by the caller.
            </summary>
            <param name="r">The binary reader.</param>
            <param name="streamVersion">The version of the stream.</param>
            <param name="badEndOfFile">True whenever the end of file is the result of an <see cref="T:System.IO.EndOfStreamException"/>.</param>
            <returns>The log entry or null if a zero byte (end marker) has been found.</returns>
        </member>
        <member name="T:CK.Monitoring.LogReader">
            <summary>
            A log reader acts as an enumerator of <see cref="T:CK.Monitoring.ILogEntry"/> that are stored in a <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="F:CK.Monitoring.LogReader.CurrentStreamVersion">
            <summary>
            Current version stamp. Writes are done with this version, but reads MUST handle it.
            The first released version is 5.
            </summary>
        </member>
        <member name="F:CK.Monitoring.LogReader.FileHeader">
            <summary>
            The file header for .ckmon files starting from CurrentStreamVersion = 5.
            That's C, K, M, O and N (ASCII).
            </summary>
        </member>
        <member name="M:CK.Monitoring.LogReader.#ctor(System.IO.Stream,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Monitoring.LogReader"/> on an uncompressed stream with an explicit version number.
            </summary>
            <param name="stream">Stream to read logs from.</param>
            <param name="streamVersion">Version of the log stream.</param>
            <param name="headerLength">Length of the header. This will be substracted to the actual stream position to compute the <see cref="P:CK.Monitoring.LogReader.StreamOffset"/>.</param>
            <param name="mustClose">
            Defaults to true (the stream will be automatically closed).
            False to let the stream opened once this reader is disposed, the end of the log data is reached or an error is encountered.
            </param>
        </member>
        <member name="M:CK.Monitoring.LogReader.Open(System.String,System.Int64,CK.Monitoring.LogReader.MulticastFilter)">
            <summary>
            Opens a <see cref="T:CK.Monitoring.LogReader"/> to read the content of a compressed or uncompressed file.
            The file will be closed when <see cref="M:CK.Monitoring.LogReader.Dispose"/> will be called.
            </summary>
            <param name="path">Path of the log file.</param>
            <param name="dataOffset">
            An optional offset where the stream position must be initially set: this is the position of an entry in the actual (potentially uncompressed stream),
            not the offset in the original stream.
            </param>
            <param name="filter">An optional <see cref="T:CK.Monitoring.LogReader.MulticastFilter"/>.</param>
            <returns>A <see cref="T:CK.Monitoring.LogReader"/> that will close the file when disposed.</returns>
            <remarks>
            .ckmon files exist in different file versions, depending on headers.
            The file can be compressed using GZipStream, in which case the header will be the magic GZIP header: 1F 8B.
            New header (applies to version 5), the file will start with 43 4B 4D 4F 4E (CKMON in ASCII), followed by the version number, instead of only the version number.
            </remarks>
        </member>
        <member name="M:CK.Monitoring.LogReader.Open(System.IO.Stream,System.Int64,CK.Monitoring.LogReader.MulticastFilter)">
            <summary>
            Opens a <see cref="T:CK.Monitoring.LogReader"/> to read the content of a compressed or uncompressed stream.
            The stream will be closed when <see cref="M:CK.Monitoring.LogReader.Dispose"/> will be called.
            </summary>
            <param name="seekableStream">Stream that must support Seek operations (<see cref="P:System.IO.Stream.CanSeek"/> must be true).</param>
            <param name="dataOffset">
            An optional offset where the stream position must be initially set: this is the position of an entry in the actual (potentially uncompressed stream),
            not the offset in the original stream.
            </param>
            <param name="filter">An optional <see cref="T:CK.Monitoring.LogReader.MulticastFilter"/>.</param>
            <returns>A <see cref="T:CK.Monitoring.LogReader"/> that will close the file when disposed.</returns>
            <remarks>
            .ckmon files exist in different file versions, depending on headers.
            The file can be compressed using GZipStream, in which case the header will be the magic GZIP header: 1F 8B.
            New header (applies to version 5), the file will start with 43 4B 4D 4F 4E (CKMON in ASCII), followed by the version number, instead of only the version number.
            </remarks>
        </member>
        <member name="T:CK.Monitoring.LogReader.MulticastFilter">
            <summary>
            Enables filtering of a multi-cast stream: only entries from the specified monitor will be read. 
            </summary>
        </member>
        <member name="F:CK.Monitoring.LogReader.MulticastFilter.MonitorId">
            <summary>
            The filtered monitor identifier.
            </summary>
        </member>
        <member name="F:CK.Monitoring.LogReader.MulticastFilter.KnownLastMonitorEntryOffset">
            <summary>
            The offset of the last entry in the stream (see <see cref="P:CK.Monitoring.LogReader.StreamOffset"/>).
            <see cref="F:System.Int64.MaxValue"/> when unknown.
            </summary>
        </member>
        <member name="M:CK.Monitoring.LogReader.MulticastFilter.#ctor(System.Guid,System.Int64)">
            <summary>
            Initializes a new <see cref="T:CK.Monitoring.LogReader.MulticastFilter"/>.
            </summary>
            <param name="monitorId">Monitor identifier to filter.</param>
            <param name="knownLastMonitorEntryOffset">Offset of the last entry in the stream (when known this enables to stop processing as soon as possible).</param>
        </member>
        <member name="P:CK.Monitoring.LogReader.CurrentFilter">
            <summary>
            Gets or sets a <see cref="T:CK.Monitoring.LogReader.MulticastFilter"/> that will be taken into account during the next <see cref="M:CK.Monitoring.LogReader.MoveNext"/>.
            Only entries from this monitor will be extracted when reading a <see cref="T:CK.Monitoring.IMulticastLogEntry"/> (pure unicast <see cref="T:CK.Monitoring.ILogEntry"/> will be ignored).
            </summary>
            <remarks>
            Note that the <see cref="P:CK.Monitoring.LogReader.Current"/> will be <see cref="T:CK.Monitoring.ILogEntry"/> objects: multi-cast entry properties (<see cref="P:CK.Monitoring.IMulticastLogInfo.MonitorId"/> 
            and <see cref="P:CK.Monitoring.IMulticastLogEntry.GroupDepth"/>) are no more available when a filter is set.
            </remarks>
        </member>
        <member name="P:CK.Monitoring.LogReader.StreamVersion">
            <summary>
            Gets the stream version. It is available only after the first call to <see cref="M:CK.Monitoring.LogReader.MoveNext"/>.
            </summary>
        </member>
        <member name="P:CK.Monitoring.LogReader.Current">
            <summary>
            Current <see cref="T:CK.Monitoring.ILogEntry"/> that can be a <see cref="T:CK.Monitoring.IMulticastLogEntry"/>.
            As usual, <see cref="M:CK.Monitoring.LogReader.MoveNext"/> must be called before getting the first entry.
            </summary>
        </member>
        <member name="P:CK.Monitoring.LogReader.CurrentMulticast">
            <summary>
            Gets the <see cref="P:CK.Monitoring.LogReader.Current"/> entry if the underlying entry is a <see cref="T:CK.Monitoring.IMulticastLogEntry"/>, null otherwise.
            This captures the actual entry when a <see cref="P:CK.Monitoring.LogReader.CurrentFilter"/> is set (Current is then a mere Unicast entry).
            </summary>
        </member>
        <member name="P:CK.Monitoring.LogReader.ReadException">
            <summary>
            Gets the exception that may have been thrown when reading the file.
            </summary>
        </member>
        <member name="P:CK.Monitoring.LogReader.BadEndOfFileMarker">
            <summary>
            Gets whether the end of file has been reached and the file is missing the final 0 byte marker.
            </summary>
        </member>
        <member name="P:CK.Monitoring.LogReader.CurrentMulticastWithOffset">
            <summary>
            Current <see cref="T:CK.Monitoring.IMulticastLogEntry"/> with its associated position in the stream.
            The current entry must be a multi-cast one and, as usual, <see cref="M:CK.Monitoring.LogReader.MoveNext"/> must be called before getting the first entry.
            </summary>
        </member>
        <member name="P:CK.Monitoring.LogReader.StreamOffset">
            <summary>
            Gets the inner <see cref="P:System.IO.Stream.Position"/> of the <see cref="P:CK.Monitoring.LogReader.Current"/> entry.
            </summary>
        </member>
        <member name="M:CK.Monitoring.LogReader.MoveNext">
            <summary>
            Attempts to read the next <see cref="T:CK.Monitoring.ILogEntry"/>.
            </summary>
            <returns>True on success, false otherwise.</returns>
        </member>
        <member name="M:CK.Monitoring.LogReader.Dispose">
            <summary>
            Close the inner stream (.Net 4.5 only: if this reader has been asked to do so thanks to constructors' parameter mustClose sets to true).
            </summary>
        </member>
        <member name="T:CK.Monitoring.LogReaderStreamInfo">
            <summary>
            Container for an uncompressed log stream and other meta-information.
            </summary>
        </member>
        <member name="F:CK.Monitoring.LogReaderStreamInfo.LogStream">
            <summary>
            Gets the log stream: it is opened and uncompressed. Its position is before the version number if Version is equal to -1; otherwise, it is after.
            </summary>
            <value>
            </value>
        </member>
        <member name="F:CK.Monitoring.LogReaderStreamInfo.IsCompressed">
            <summary>
            Gets a value indicating whether the log stream is contained in a compressed stream.
            <c>true</c> if the log stream is contained in a compressed stream; otherwise, <c>false</c>.
            </summary>
        </member>
        <member name="F:CK.Monitoring.LogReaderStreamInfo.Version">
            <summary>
            The version.
            </summary>
        </member>
        <member name="F:CK.Monitoring.LogReaderStreamInfo.HeaderLength">
            <summary>
            The length of the version header.
            </summary>
        </member>
        <member name="M:CK.Monitoring.LogReaderStreamInfo.OpenStream(System.IO.Stream)">
            <summary>
            Opens a log stream, handling version and compression.
            On success, its Stream positionned after the header (before the first log entry).
            Supports headers:
            - Old version header (05 00 00 00)
            - CKMOD header (43 4B 4D 4F 4E) followed by version
            - RFC 1952 GZIP header (1F 8B), will be handled automatically by: a GZip stream reader will be created.
            </summary>
            <param name="seekableStream">Log stream to read.</param>
            <returns>LogReader information.</returns>
        </member>
        <member name="T:CK.Monitoring.MulticastLogEntryWithOffset">
            <summary>
            Immutable capture of a log <see cref="F:CK.Monitoring.MulticastLogEntryWithOffset.Entry"/> and its <see cref="F:CK.Monitoring.MulticastLogEntryWithOffset.Offset"/>.
            </summary>
        </member>
        <member name="F:CK.Monitoring.MulticastLogEntryWithOffset.Entry">
            <summary>
            The log entry.
            </summary>
        </member>
        <member name="F:CK.Monitoring.MulticastLogEntryWithOffset.Offset">
            <summary>
            The entry's offset.
            </summary>
        </member>
        <member name="M:CK.Monitoring.MulticastLogEntryWithOffset.#ctor(CK.Monitoring.IMulticastLogEntry,System.Int64)">
            <summary>
            Initializes a new <see cref="T:CK.Monitoring.MulticastLogEntryWithOffset"/>.
            </summary>
            <param name="e">The entry.</param>
            <param name="o">The offset.</param>
        </member>
        <member name="T:CK.Monitoring.MultiLogReader">
            <summary>
            This reader process multiples .ckmon files (possibly in different steps: it internally aggregates the result) and can 
            create <see cref="T:CK.Monitoring.MultiLogReader.ActivityMap"/> objects on demand.
            It is a thread safe object (the ActivityMap is immutable).
            </summary>
        </member>
        <member name="T:CK.Monitoring.MultiLogReader.ActivityMap">
            <summary>
            Immutable snapshot of a <see cref="T:CK.Monitoring.MultiLogReader"/>'s content.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.ActivityMap.FirstEntryDate">
            <summary>
            Gets the very first entry time (among all <see cref="P:CK.Monitoring.MultiLogReader.ActivityMap.Monitors"/>).
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.ActivityMap.LastEntryDate">
            <summary>
            Gets the very last entry time (among all <see cref="P:CK.Monitoring.MultiLogReader.ActivityMap.Monitors"/>).
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.ActivityMap.ValidFiles">
            <summary>
            Gets the valid files (see <see cref="P:CK.Monitoring.MultiLogReader.RawLogFile.IsValidFile"/>).
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.ActivityMap.AllFiles">
            <summary>
            Gets all files (even the ones for which <see cref="P:CK.Monitoring.MultiLogReader.RawLogFile.IsValidFile"/> is false).
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.ActivityMap.Monitors">
            <summary>
            Gets all the monitors that this ActivityMap contains ordered by their <see cref="P:CK.Monitoring.MultiLogReader.Monitor.FirstEntryTime"/>.
            </summary>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.ActivityMap.FindMonitor(System.Guid)">
            <summary>
            Finds a <see cref="T:CK.Monitoring.MultiLogReader.Monitor"/> by its identifier.
            </summary>
            <param name="monitorId">The monitor's identifier.</param>
            <returns>The monitor or null if not found.</returns>
        </member>
        <member name="T:CK.Monitoring.MultiLogReader.Monitor">
            <summary>
            Immutable information that describes one monitor's content.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.Monitor.MonitorId">
            <summary>
            Gets the monitor's identifier.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.Monitor.Files">
            <summary>
            Gets the different files where entries from this monitor appear.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.Monitor.FirstEntryTime">
            <summary>
            Gets the very first known entry time for this monitor.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.Monitor.FirstDepth">
            <summary>
            Gets the very first known depth for this monitor.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.Monitor.LastEntryTime">
            <summary>
            Gets the very last known entry time for this monitor.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.Monitor.LastDepth">
            <summary>
            Gets the very last known depth for this monitor.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.Monitor.AllTags">
            <summary>
            Gets the weighted occurrences of each tags that have been logged in this monitor.
            </summary>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.Monitor.MultiFileReader.OneLogReader.CompareHeadTime(CK.Monitoring.MultiLogReader.Monitor.MultiFileReader.OneLogReader,CK.Monitoring.MultiLogReader.Monitor.MultiFileReader.OneLogReader)">
            <summary>
            Compares Head.Entry.LogTime. 
            </summary>
        </member>
        <member name="T:CK.Monitoring.MultiLogReader.Monitor.LivePage">
            <summary>
            A page gives access to <see cref="P:CK.Monitoring.MultiLogReader.Monitor.LivePage.Entries"/> by unifying all the raw log files and removing duplicates from them.
            Pages are sequentially accessed from a first page (obtained by <see cref="G:Monitor.ReadFirstPage"/>) and the by calling <see cref="M:CK.Monitoring.MultiLogReader.Monitor.LivePage.ForwardPage"/>.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.Monitor.LivePage.Entries">
            <summary>
            Gets the log entries of the current page.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.Monitor.LivePage.PageLength">
            <summary>
            Gets the page length. 
            </summary>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.Monitor.LivePage.ForwardPage">
            <summary>
            Loads the next page.
            </summary>
            <returns>The number of entries.</returns>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.Monitor.LivePage.Dispose">
            <summary>
            Closes all resources.
            </summary>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.Monitor.ReadFirstPage(System.Int32)">
            <summary>
            Loads the first available entries.
            </summary>
            <param name="pageLength">The length of pages. Must be greater than 0.</param>
            <returns>The first <see cref="T:CK.Monitoring.MultiLogReader.Monitor.LivePage"/> from which next pages can be retrieved.</returns>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.Monitor.ReadFirstPage(CK.Core.DateTimeStamp,System.Int32)">
            <summary>
            Loads the first available entries starting at a given time.
            </summary>
            <param name="firstLogTime">The first log time.</param>
            <param name="pageLength">The length of pages. Must be greater than 0.</param>
            <returns>The first <see cref="T:CK.Monitoring.MultiLogReader.Monitor.LivePage"/> from which next pages can be retrieved.</returns>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.Monitor.Replay(CK.Core.IActivityMonitor,CK.Core.IActivityMonitor)">
            <summary>
            Replays this monitor's content into another monitor.
            </summary>
            <param name="replay">The target monitor. Can not be null.</param>
            <param name="m">Optional monitor (nothing is logged when null).</param>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.GetActivityMap">
            <summary>
            Gets the <see cref="T:CK.Monitoring.MultiLogReader.ActivityMap"/> from this reader.
            </summary>
            <returns>An immutable snapshot of this reader's content.</returns>
        </member>
        <member name="T:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence">
            <summary>
            Immutable object that describes the occurrence of a Monitor in a <see cref="T:CK.Monitoring.MultiLogReader.RawLogFile"/>.
            </summary>
        </member>
        <member name="F:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.LogFile">
            <summary>
            The <see cref="T:CK.Monitoring.MultiLogReader.RawLogFile"/>.
            </summary>
        </member>
        <member name="F:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.MonitorId">
            <summary>
            The monitor's identifier.
            </summary>
        </member>
        <member name="F:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.FirstOffset">
            <summary>
            First offset for this <see cref="F:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.MonitorId"/> in this <see cref="F:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.LogFile"/>.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.LastOffset">
            <summary>
            Last offset for this <see cref="F:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.MonitorId"/> in this <see cref="F:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.LogFile"/>.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.FirstEntryTime">
            <summary>
            First entry time for this <see cref="F:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.MonitorId"/> in this <see cref="F:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.LogFile"/>.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.LastEntryTime">
            <summary>
            Last entry time for this <see cref="F:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.MonitorId"/> in this <see cref="F:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.LogFile"/>.
            </summary>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.CreateFilteredReader(System.Int64)">
            <summary>
            Creates and opens a <see cref="T:CK.Monitoring.LogReader"/> that reads unicast entries only from this monitor.
            The reader is initially positioned before the entry (i.e. <see cref="M:CK.Monitoring.LogReader.MoveNext"/> must be called).
            </summary>
            <param name="streamOffset">Initial stream position.</param>
            <returns>A log reader that will read only entries from this monitor.</returns>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.RawLogFileMonitorOccurence.CreateFilteredReaderAndMoveTo(CK.Core.DateTimeStamp)">
            <summary>
            Opens a <see cref="T:CK.Monitoring.LogReader"/> that reads unicast entries only from this monitor and positions it on the first entry
            with the given time (i.e. <see cref="M:CK.Monitoring.LogReader.MoveNext"/> has been called).
            </summary>
            <param name="logTime">Log time. Must exist in the stream otherwise an exception is thrown.</param>
            <returns>A log reader that will read only entries from this monitor.</returns>
        </member>
        <member name="T:CK.Monitoring.MultiLogReader.RawLogFile">
            <summary>
            Immutable object that contains a description of the content of a raw log file.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.RawLogFile.FileName">
            <summary>
            Gets the file name.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.RawLogFile.FirstEntryTime">
            <summary>
            Gets the first entry time.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.RawLogFile.LastEntryTime">
            <summary>
            Gets the last entry time.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.RawLogFile.FileVersion">
            <summary>
            Gets the file version.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.RawLogFile.TotalEntryCount">
            <summary>
            Gets the total number of entries.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.RawLogFile.BadEndOfFile">
            <summary>
            Gets whether this file does not end with the end of stream marker (a zero byte).
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.RawLogFile.IsValidFile">
            <summary>
            Gets whether no <see cref="P:CK.Monitoring.MultiLogReader.RawLogFile.Error"/> occurred and there is no <see cref="P:CK.Monitoring.MultiLogReader.RawLogFile.BadEndOfFile"/>.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.RawLogFile.Error">
            <summary>
            Gets the <see cref="T:System.Exception"/> that occurred while reading file.
            </summary>
        </member>
        <member name="P:CK.Monitoring.MultiLogReader.RawLogFile.Monitors">
            <summary>
            Gets the different monitors that appear in this file.
            </summary>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.RawLogFile.ToString">
            <summary>
            Overridden to return details about its content.
            </summary>
            <returns>Detailed string.</returns>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Monitoring.MultiLogReader"/>.
            </summary>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.Add(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Adds a bunch of log files.
            </summary>
            <param name="files">Set of files to add.</param>
            <returns>List of newly added files (already known files are skipped).</returns>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.Add(System.String,System.Boolean@)">
            <summary>
            Adds a file to this reader. This is thread safe (can be called from any thread at any time). 
            </summary>
            <param name="filePath">The path of the file to add.</param>
            <param name="newFileIndex">True if the file has actually been added, false it it was already added.</param>
            <returns>The RawLogFile object (newly created or already existing).</returns>
        </member>
        <member name="M:CK.Monitoring.MultiLogReader.Dispose">
            <summary>
            Releases this reader.
            </summary>
        </member>
        <member name="T:CK.Monitoring.ParentedLogEntry">
            <summary>
            Parented log entry binds an entry to its parent group and can be a missing entry (a line or group opening or closing that we know it exists
            but have no data for it or only their <see cref="P:CK.Monitoring.ILogEntry.LogTime"/>).
            </summary>
        </member>
        <member name="F:CK.Monitoring.ParentedLogEntry.Parent">
            <summary>
            Parent entry. Null when there is no group above.
            </summary>
        </member>
        <member name="F:CK.Monitoring.ParentedLogEntry.Entry">
            <summary>
            The entry itself.
            </summary>
        </member>
        <member name="P:CK.Monitoring.ParentedLogEntry.IsMissing">
            <summary>
            Gets whether this is actually a missing entry (it can be a group opening, closing or a mere line): we do not have data for it, except, may be its <see cref="P:CK.Monitoring.ILogEntry.LogTime"/>
            (if the log time is not known, the <see cref="F:CK.Monitoring.ParentedLogEntry.Entry"/>'s <see cref="P:CK.Monitoring.ILogEntry.LogTime">LogTime</see> is <see cref="F:CK.Core.DateTimeStamp.Unknown"/>).
            </summary>
        </member>
        <member name="M:CK.Monitoring.ParentedLogEntry.GetPath(System.Collections.Generic.List{CK.Monitoring.ILogEntry},System.Boolean)">
            <summary>
            Collects path of <see cref="T:CK.Monitoring.ILogEntry"/> in a reusable list (the buffer is <see cref="M:System.Collections.Generic.List`1.Clear">cleared</see> first).
            </summary>
            <param name="reusableBuffer">List that will be cleared and filled with parents.</param>
            <param name="addThis">Set it to true to append to also add this entry.</param>
        </member>
        <member name="M:CK.Monitoring.ParentedLogEntry.CollectPath(System.Action{CK.Monitoring.ParentedLogEntry},System.Boolean)">
            <summary>
            Collects the path of this <see cref="T:CK.Monitoring.ParentedLogEntry"/>, optionally terminated with this entry.
            </summary>
            <param name="collector">Action for each item.</param>
            <param name="addThis">Set it to true to append to also call the collector with this entry.</param>
        </member>
        <member name="T:CK.RouteConfig.ActionConfiguration">
            <summary>
            Configuration for an action defines a <see cref="P:CK.RouteConfig.ActionConfiguration.Name"/>.
            This name must be unique among its sequence.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.ActionConfiguration.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:CK.RouteConfig.ActionConfiguration"/>.
            </summary>
            <param name="name">Required non empty name that identifies this configuration. Can not be null.</param>
        </member>
        <member name="P:CK.RouteConfig.ActionConfiguration.Name">
            <summary>
            Gets or sets the name of this configuration. Can not be null.
            </summary>
            <remarks>
            Whether this name is a valid one or not is not checked by the configuration itself
            but by the <see cref="T:CK.RouteConfig.Impl.MetaConfiguration"/> that "covers" it: different rules may be 
            implemented for the name of a configuration depending of the way it is used, this is 
            the role of the meta configuration.
            </remarks>
        </member>
        <member name="M:CK.RouteConfig.ActionConfiguration.CheckValidity(System.String,CK.Core.IActivityMonitor)">
            <summary>
            Checks the configuration validity. By default returns true.
            </summary>
            <param name="routeName">Name of the route that contains the configuration.</param>
            <param name="monitor">Monitor to use to explain errors.</param>
            <returns>True if the configuration is valid, false otherwise.</returns>
        </member>
        <member name="P:CK.RouteConfig.ActionConfiguration.IsCloneable">
            <summary>
            Gets whether this configuration is clone-able.
            Defaults to false.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.ActionConfiguration.Clone">
            <summary>
            Clones this configuration.
            By default throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
            <returns>A clone.</returns>
        </member>
        <member name="T:CK.RouteConfig.ActionConfigurationResolved">
            <summary>
            Resolved action configurations belong to <see cref="T:CK.RouteConfig.RouteConfigurationResolved"/> and <see cref="T:CK.RouteConfig.SubRouteConfigurationResolved"/>.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.ActionConfigurationResolved.Name">
            <summary>
            Gets the name of the action.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.ActionConfigurationResolved.FullName">
            <summary>
            Gets the full name of the action (this <see cref="P:CK.RouteConfig.ActionConfigurationResolved.Path"/>/<see cref="P:CK.RouteConfig.ActionConfigurationResolved.Name"/>).
            </summary>
        </member>
        <member name="P:CK.RouteConfig.ActionConfigurationResolved.Path">
            <summary>
            Path of this action.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.ActionConfigurationResolved.Index">
            <summary>
            Gets the index of this action in its route or in its composite.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.ActionConfigurationResolved.ActionConfiguration">
            <summary>
            Gets the action configuration instance (possibly shared by multiple routes if the <see cref="P:CK.RouteConfig.ActionConfigurationResolved.ActionConfiguration"/>.<see cref="P:ActionConfiguration.IsCloneable"/> is false).
            </summary>
        </member>
        <member name="M:CK.RouteConfig.ActionConfigurationResolved.Create(CK.Core.IActivityMonitor,CK.RouteConfig.ActionConfiguration,System.Boolean,System.Int32,System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
            Internal factory for ActionConfigurationResolved avoids externally visible virtual protected method on ActionConfiguration.
            This prevents any other composite implementations than our.
            </summary>
        </member>
        <member name="T:CK.RouteConfig.ActionParallelConfiguration">
            <summary>
            Specialized composite for parallel configuration.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.ActionParallelConfiguration.#ctor(System.String)">
            <summary>
            Initializes a new parallel.
            </summary>
            <param name="name">Name of the configuration.</param>
        </member>
        <member name="M:CK.RouteConfig.ActionParallelConfiguration.AddAction(CK.RouteConfig.ActionConfiguration)">
            <summary>
            Overridden to return a this as a <see cref="T:CK.RouteConfig.ActionParallelConfiguration"/> for fluent syntax.
            </summary>
            <param name="a">The action to add.</param>
            <returns>This parallel.</returns>
        </member>
        <member name="T:CK.RouteConfig.ActionSequenceConfiguration">
            <summary>
            Specialized composite for sequence configuration.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.ActionSequenceConfiguration.#ctor(System.String)">
            <summary>
            Initializes a new sequence.
            </summary>
            <param name="name">Name of the configuration.</param>
        </member>
        <member name="M:CK.RouteConfig.ActionSequenceConfiguration.AddAction(CK.RouteConfig.ActionConfiguration)">
            <summary>
            Overridden to return a this as a <see cref="T:CK.RouteConfig.ActionSequenceConfiguration"/> for fluent syntax.
            </summary>
            <param name="a">The action to add.</param>
            <returns>This sequence.</returns>
        </member>
        <member name="T:CK.RouteConfig.ConfiguredRouteHost`2">
            <summary>
            Thread-safe management of hierarchical routes configured (and reconfigured) by a <see cref="T:CK.RouteConfig.RouteConfiguration"/>.
            </summary>
            <typeparam name="TAction">Actual type of the actions. Can be any reference type.</typeparam>
            <typeparam name="TRoute">Route class that encapsulates actions.</typeparam>
        </member>
        <member name="M:CK.RouteConfig.ConfiguredRouteHost`2.#ctor(CK.RouteConfig.RouteActionFactory{`0,`1},System.Action{CK.RouteConfig.ConfiguredRouteHost{`0,`1}.ConfigurationReady},System.Action{CK.Core.IActivityMonitor,`0},System.Action{CK.Core.IActivityMonitor,`0})">
            <summary>
            Initializes a new <see cref="T:CK.RouteConfig.ConfiguredRouteHost`2"/> initially <see cref="P:CK.RouteConfig.ConfiguredRouteHost`2.IsEmpty">empty</see>.
            </summary>
            <param name="actionFactory">Factory for <typeparamref name="TAction"/> based on an <see cref="T:CK.RouteConfig.ActionConfiguration"/> for final <typeparamref name="TRoute"/>.</param>
            <param name="readyCallback">Optional callback that will be called right before applying a new configuration.</param>
            <param name="starter">Optional starter function for a <typeparamref name="TAction"/>.</param>
            <param name="closer">Optional closer function.</param>
        </member>
        <member name="M:CK.RouteConfig.ConfiguredRouteHost`2.ObtainRoute(System.String)">
            <summary>
            Returns the <typeparamref name="TRoute"/> for a full name.
            Obtaining a route locks the configuration: it must be unlocked when not used anymore.
            When null, it means that a configuration is waiting to be applied (a route that buffers its work should be substituted)
            or that this host <see cref="P:CK.RouteConfig.ConfiguredRouteHost`2.IsDisposed">is disposed</see>.
            </summary>
            <param name="route">The full route that will be matched.</param>
            <returns>The final route to apply or null if a configuration is applying or if <see cref="P:CK.RouteConfig.ConfiguredRouteHost`2.IsDisposed"/> is true.</returns>
        </member>
        <member name="P:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationAttemptCount">
            <summary>
            Gets the total number of calls to <see cref="M:CK.RouteConfig.ConfiguredRouteHost`2.SetConfiguration(CK.Core.IActivityMonitor,CK.RouteConfig.RouteConfiguration,System.Int32)"/> (and to <see cref="M:CK.RouteConfig.ConfiguredRouteHost`2.Dispose"/> method).
            This can be used to call <see cref="M:CK.RouteConfig.ConfiguredRouteHost`2.WaitForNextConfiguration(System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.ConfiguredRouteHost`2.SuccessfulConfigurationCount">
            <summary>
            Gets the total number of successful calls to <see cref="M:CK.RouteConfig.ConfiguredRouteHost`2.SetConfiguration(CK.Core.IActivityMonitor,CK.RouteConfig.RouteConfiguration,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.ConfiguredRouteHost`2.IsEmpty">
            <summary>
            Gets whether this host is closed.
            When closed, all routes are empty.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.ConfiguredRouteHost`2.IsDisposed">
            <summary>
            Gets whether this host has been disposed.
            When disposed, <see cref="M:CK.RouteConfig.ConfiguredRouteHost`2.ObtainRoute(System.String)"/> always returns null.
            </summary>
        </member>
        <member name="T:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationClosingEventArgs">
            <summary>
            Event argument raised by <see cref="E:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationClosing"/>.
            </summary>
        </member>
        <member name="F:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationClosingEventArgs.NewConfiguration">
            <summary>
            The configuration waiting to be applied.
            Null when the host is disposed.
            </summary>
        </member>
        <member name="F:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationClosingEventArgs.Monitor">
            <summary>
            The <see cref="T:CK.Core.IActivityMonitor"/> that monitors the change of the configuration.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationClosingEventArgs.IsDisposed">
            <summary>
            Gets whether the host is disposed.
            </summary>
        </member>
        <member name="T:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationReady">
            <summary>
            Argument of the callback called when the configuration is ready to be applied.
            </summary>
        </member>
        <member name="F:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationReady.Monitor">
            <summary>
            The <see cref="T:CK.Core.IActivityMonitor"/> that monitors the change of the configuration.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationReady.IsEmptyConfiguration">
            <summary>
            Gets whether the new configuration is empty.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationReady.ObtainRoute(System.String)">
            <summary>
            Returns the <typeparamref name="TRoute"/> for a full name based on the new configuration.
            This obtention locks the configuration: it must be unlocked when not used anymore.
            </summary>
            <param name="route">The full route that will be matched.</param>
            <returns>The final route to use.</returns>
        </member>
        <member name="M:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationReady.GetAllRoutes">
            <summary>
            Gets all future routes. This must be used before calling <see cref="M:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationReady.ApplyConfiguration"/> otherwise 
            an <see cref="T:System.InvalidOperationException"/> is thrown.
            Ordering corresponds to a depth-first traversal.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationReady.ApplyConfiguration">
            <summary>
            Applies pending configuration: new routes are set on the host, <see cref="M:CK.RouteConfig.ConfiguredRouteHost`2.ObtainRoute(System.String)"/> now returns the new ones.
            If this method is not called during the call back, it is automatically called before leaving <see cref="M:CK.RouteConfig.ConfiguredRouteHost`2.SetConfiguration(CK.Core.IActivityMonitor,CK.RouteConfig.RouteConfiguration,System.Int32)">SetConfiguration</see>.
            </summary>
        </member>
        <member name="E:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationClosing">
            <summary>
            Event raised by <see cref="M:CK.RouteConfig.ConfiguredRouteHost`2.SetConfiguration(CK.Core.IActivityMonitor,CK.RouteConfig.RouteConfiguration,System.Int32)"/> when current configured routes must be released.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.ConfiguredRouteHost`2.SetConfiguration(CK.Core.IActivityMonitor,CK.RouteConfig.RouteConfiguration,System.Int32)">
            <summary>
            Sets a new <see cref="T:CK.RouteConfig.RouteConfiguration"/>.
            <list type="number">
            <item>If the new routes can not be created, false is returned and current configuration remains active.</item>
            <item><see cref="M:CK.RouteConfig.ConfiguredRouteHost`2.ObtainRoute(System.String)"/> starts returning null and <see cref="E:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationClosing"/> event is raised.</item>
            <item>Waiting for previous routes termination (uninitialization).</item>
            <item>Initializing the new routes (starter function when provided to the constructor is called for each actions).</item>
            <item>Calling ConfigurationReady callback: new routes can be initialized.</item>
            <item>If the new configuration has not been applied by the ConfigurationReady callback, it is automatically applied.</item>
            </list>
            If an error occurs while starting the new routes, false is returned and routes are empty.
            </summary>
            <param name="monitor">Monitor that will receive explanations and errors.</param>
            <param name="configuration">The configuration to achieve.</param>
            <param name="millisecondsBeforeForceClose">Maximal time to wait for current routes to be unlocked (see <see cref="T:CK.RouteConfig.IRouteConfigurationLock"/>).</param>
            <returns>True if the new configuration has been successfully applied, false if an error occurred.</returns>
        </member>
        <member name="M:CK.RouteConfig.ConfiguredRouteHost`2.WaitForAppliedPendingConfiguration(System.Int32)">
            <summary>
            Blocks the caller if a new configuration is waiting to be applied until it has effectively be applied.
            </summary>
            <param name="millisecondsTimeout">Maximum number of milliseconds to wait.</param>
            <returns>False if specified timeout expired.</returns>
        </member>
        <member name="M:CK.RouteConfig.ConfiguredRouteHost`2.WaitForNextConfiguration(System.Int32,System.Int32)">
            <summary>
            Blocks the caller until the current <see cref="P:CK.RouteConfig.ConfiguredRouteHost`2.ConfigurationAttemptCount"/> is greater or equal to the given number and the last 
            configuration has been applied (or this object is disposed).
            </summary>
            <param name="configurationAttemptCount">The number of configuration attempt count to wait for.</param>
            <param name="millisecondsTimeout">Maximum number of milliseconds to wait. Use <see cref="F:System.Threading.Timeout.Infinite"/> or -1 for no limit.</param>
            <returns>False if specified timeout expired.</returns>
        </member>
        <member name="M:CK.RouteConfig.ConfiguredRouteHost`2.Dispose(CK.Core.IActivityMonitor,System.Int32)">
            <summary>
            Closes the current configuration. 
            Current actions are closed. <see cref="P:CK.RouteConfig.ConfiguredRouteHost`2.IsDisposed"/> is set to true.
            </summary>
            <param name="monitor">Monitor that will be used. Must not be null.</param>
            <param name="millisecondsBeforeForceClose">Maximal time to wait for current routes to be unlocked (see <see cref="T:CK.RouteConfig.IRouteConfigurationLock"/>).</param>
            <returns>Returns true if this host has actually been disposed, false if it has already been disposed.</returns>
        </member>
        <member name="M:CK.RouteConfig.ConfiguredRouteHost`2.Dispose">
            <summary>
            Calls <see cref="M:CK.RouteConfig.ConfiguredRouteHost`2.Dispose(CK.Core.IActivityMonitor,System.Int32)"/> with a <see cref="T:CK.Core.SystemActivityMonitor"/> and no closing time limit.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.ConfiguredRouteHost`2.Dispose(System.Boolean)">
            <summary>
            Calls <see cref="M:CK.RouteConfig.ConfiguredRouteHost`2.Dispose(CK.Core.IActivityMonitor,System.Int32)"/> with a <see cref="T:CK.Core.SystemActivityMonitor"/> and no closing time limit.
            </summary>
            <param name="disposing">True when called from code (managed and unmanaged resources must be disposed), false when called from the Garbage collector (only unmanaged resources should be closed in such case).</param>
        </member>
        <member name="M:CK.RouteConfig.ConfiguredRouteHost`2.Finalize">
            <summary>
            Standard Dispose/Finalizer pattern (calls <see cref="M:CK.RouteConfig.ConfiguredRouteHost`2.Dispose(System.Boolean)">Dispose(false)</see>. 
            Here to support release of unmanaged resources by specialization.
            </summary>
        </member>
        <member name="T:CK.RouteConfig.Impl.ActionCompositeConfiguration">
            <summary>
            Defines a composite action that can be a <see cref="T:CK.RouteConfig.ActionParallelConfiguration"/> or a <see cref="T:CK.RouteConfig.ActionSequenceConfiguration"/>.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.Impl.ActionCompositeConfiguration.#ctor(System.String,System.Boolean)">
            <summary>
            Protected constructor.
            </summary>
            <param name="name">Action's name.</param>
            <param name="isParallel">Whether this composite is a parallel.</param>
        </member>
        <member name="P:CK.RouteConfig.Impl.ActionCompositeConfiguration.IsParallel">
            <summary>
            Gets whether this is a parallel composite.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.Impl.ActionCompositeConfiguration.Children">
            <summary>
            Gets children (items of this composite) actions.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.Impl.ActionCompositeConfiguration.CheckValidity(System.String,CK.Core.IActivityMonitor)">
            <summary>
            Checks that children are valid (action's name must be unique).
            </summary>
            <param name="routeName">Name of the route that references this action.</param>
            <param name="monitor">Monitor to report errors.</param>
            <returns>True if valid, false otherwise.</returns>
        </member>
        <member name="M:CK.RouteConfig.Impl.ActionCompositeConfiguration.Add(CK.RouteConfig.ActionConfiguration)">
            <summary>
            Adds an <see cref="T:CK.RouteConfig.ActionConfiguration"/> to this composite.
            </summary>
            <param name="action">The action to add.</param>
        </member>
        <member name="M:CK.RouteConfig.Impl.ActionCompositeConfiguration.Override(System.Int32,CK.RouteConfig.ActionConfiguration)">
            <summary>
            Overrides (replaces) an <see cref="T:CK.RouteConfig.ActionConfiguration"/> at a specified index.
            </summary>
            <param name="idx">Index to replace.</param>
            <param name="action">The new action to inject.</param>
        </member>
        <member name="P:CK.RouteConfig.Impl.ActionCompositeConfiguration.IsCloneable">
            <summary>
            Always true since one can always clone a composite.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.Impl.ActionCompositeConfiguration.Clone">
            <summary>
            Clones this composite.
            </summary>
            <returns>A clone of this composite.</returns>
        </member>
        <member name="T:CK.RouteConfig.Impl.IProtoRoute">
            <summary>
            Intermediate objects that captures the first step of configuration resolution.
            At this step we manipulate <see cref="T:CK.RouteConfig.Impl.MetaConfiguration"/> objects.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.Impl.IProtoRoute.Configuration">
            <summary>
            Gets the associated <see cref="T:CK.RouteConfig.RouteConfiguration"/> object.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.Impl.IProtoRoute.Namespace">
            <summary>
            Gets the namespace of this route.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.Impl.IProtoRoute.FullName">
            <summary>
            Gets the full name of this route.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.Impl.IProtoRoute.MetaConfigurations">
            <summary>
            Gets the list of <see cref="T:CK.RouteConfig.Impl.MetaConfiguration"/> objects such as <see cref="T:CK.RouteConfig.MetaAddActionConfiguration"/> or <see cref="T:CK.RouteConfig.MetaRemoveActionConfiguration"/>.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.Impl.IProtoRoute.FindDeclaredAction(System.String)">
            <summary>
            Finds a previously declared action.
            The action can exist in the parent routes if <see cref="P:CK.RouteConfig.SubRouteConfiguration.ImportParentDeclaredActionsAbove"/> is true (which is the default).
            </summary>
            <param name="name">Name of an existing action.</param>
            <returns>Null or the action with the name.</returns>
        </member>
        <member name="P:CK.RouteConfig.Impl.IProtoRoute.SubRoutes">
            <summary>
            Gets the list of subordinated route.
            </summary>
        </member>
        <member name="T:CK.RouteConfig.Impl.IProtoRouteConfigurationContext">
            <summary>
            Temporary context used to resolve the routes/actions associations.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.Impl.IProtoRouteConfigurationContext.Monitor">
            <summary>
            Gets the monitor to use.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.Impl.IProtoRouteConfigurationContext.AddRoute(CK.RouteConfig.SubRouteConfiguration)">
            <summary>
            Adds a new subordinated route.
            </summary>
            <param name="route">The new subordinated route.</param>
            <returns>True on success, false if an error occurred such as a name clash for the route.</returns>
        </member>
        <member name="M:CK.RouteConfig.Impl.IProtoRouteConfigurationContext.DeclareAction(CK.RouteConfig.ActionConfiguration,System.Boolean)">
            <summary>
            Declares an action that can be an override of an existing one.
            </summary>
            <param name="a">Action to declare.</param>
            <param name="overridden">True if the action overrides an existing one.</param>
            <returns>True on success, false if an error occurred such as a name clash for the action and it is not an override.</returns>
        </member>
        <member name="M:CK.RouteConfig.Impl.IProtoRouteConfigurationContext.AddMeta(CK.RouteConfig.Impl.MetaConfiguration)">
            <summary>
            Adds a <see cref="T:CK.RouteConfig.Impl.MetaConfiguration"/> to the route.
            </summary>
            <param name="meta">The meta configuration.</param>
        </member>
        <member name="T:CK.RouteConfig.Impl.IProtoSubRoute">
            <summary>
            Specialize <see cref="T:CK.RouteConfig.Impl.IProtoRoute"/> to expose a <see cref="T:CK.RouteConfig.SubRouteConfiguration"/>.
            A SubRouteConfiguration specifies the <see cref="P:CK.RouteConfig.SubRouteConfiguration.RoutePredicate"/> that is 
            the filter for the subordinated route.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.Impl.IProtoSubRoute.Configuration">
            <summary>
            Masked base <see cref="P:CK.RouteConfig.Impl.IProtoRoute.Configuration"/> so that it is a <see cref="T:CK.RouteConfig.SubRouteConfiguration"/>.
            </summary>
        </member>
        <member name="T:CK.RouteConfig.Impl.IRouteConfigurationContext">
            <summary>
            Supports for route resolution. The final <see cref="P:CK.RouteConfig.Impl.IRouteConfigurationContext.CurrentActions"/> are embedded into <see cref="T:CK.RouteConfig.RouteConfigurationResolved"/>.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.Impl.IRouteConfigurationContext.Monitor">
            <summary>
            Gets the monitor to use.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.Impl.IRouteConfigurationContext.ProtoRoute">
            <summary>
            Gets the intermediate route object.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.Impl.IRouteConfigurationContext.CurrentActions">
            <summary>
            Gets the list of <see cref="T:CK.RouteConfig.ActionConfigurationResolved"/>.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.Impl.IRouteConfigurationContext.FindExisting(System.String)">
            <summary>
            Finds an existing action by its name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:CK.RouteConfig.Impl.IRouteConfigurationContext.RemoveAction(System.String)">
            <summary>
            Removes a named action by name.
            </summary>
            <param name="name">Name of the action to remove.</param>
            <returns>True if the action has been found and removed. False otherwise.</returns>
        </member>
        <member name="M:CK.RouteConfig.Impl.IRouteConfigurationContext.AddDeclaredAction(System.String,System.String,System.Boolean)">
            <summary>
            Adds an action that has been previously declared or not: 
            <paramref name="fromMetaInsert"/> is true if we insert actions from <see cref="T:CK.RouteConfig.MetaInsertActionConfiguration"/>. 
            It is false if the action is added by a direct <see cref="T:CK.RouteConfig.MetaAddActionConfiguration"/>.
            </summary>
            <param name="name">Name of the action to add.</param>
            <param name="declaredName">Name of the declared action.</param>
            <param name="fromMetaInsert">True if this is from <see cref="T:CK.RouteConfig.MetaInsertActionConfiguration"/>, false when called by <see cref="T:CK.RouteConfig.MetaAddActionConfiguration"/>.</param>
            <returns>True if the action has been found and added.</returns>
        </member>
        <member name="T:CK.RouteConfig.Impl.MetaConfiguration">
            <summary>
            Base class for meta configuration object: those objects configure the configuration.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.Impl.MetaConfiguration.CheckValidity(System.String,CK.Core.IActivityMonitor)">
            <summary>
            Check the configuration validity.
            </summary>
            <param name="routeName">Name of the route that contains this configuration.</param>
            <param name="monitor">Monitor to use to explain errors.</param>
            <returns>True if valid, false otherwise.</returns>
        </member>
        <member name="M:CK.RouteConfig.Impl.MetaConfiguration.Apply(CK.RouteConfig.Impl.IProtoRouteConfigurationContext)">
            <summary>
            Applies the configuration (first step).
            By default, adds this meta configuration to the context so that <see cref="M:CK.RouteConfig.Impl.MetaConfiguration.Apply(CK.RouteConfig.Impl.IRouteConfigurationContext)"/> will be called.
            </summary>
            <param name="protoContext">Enables context lookup and manipulation, exposes a <see cref="T:CK.Core.IActivityMonitor"/> to use.</param>
        </member>
        <member name="M:CK.RouteConfig.Impl.MetaConfiguration.Apply(CK.RouteConfig.Impl.IRouteConfigurationContext)">
            <summary>
            Applies the configuration (second step).
            </summary>
            <param name="context">Enables context lookup and manipulation, exposes a <see cref="T:CK.Core.IActivityMonitor"/> to use.</param>
        </member>
        <member name="M:CK.RouteConfig.Impl.MetaConfiguration.CheckActionNameValidity(System.String,CK.Core.IActivityMonitor,System.String)">
            <summary>
            Implements standard name checking for <see cref="P:CK.RouteConfig.ActionConfiguration.Name"/>. 
            The provided <paramref name="nameToCheck"/> must not be null or empty or contains only whitespaces nor '/' character.
            The '/' is reserved to structure the namespace.
            </summary>
            <param name="routeName">The name of the route that contains the action.</param>
            <param name="monitor">The monitor that will receive error descriptions.</param>
            <param name="nameToCheck">The name to check.</param>
            <returns>True if the name is valid. False otherwise.</returns>
        </member>
        <member name="T:CK.RouteConfig.Impl.MetaMultiConfiguration`1">
            <summary>
            Base class for meta configuration object that handles one or more items.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.Impl.MetaMultiConfiguration`1.#ctor(`0,`0[])">
            <summary>
            Initializes a configuration with at least one item.
            </summary>
            <param name="first">First and required item.</param>
            <param name="other">Optional multiple items.</param>
        </member>
        <member name="P:CK.RouteConfig.Impl.MetaMultiConfiguration`1.Items">
            <summary>
            Gets the items.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.Impl.MetaMultiConfiguration`1.Add(`0)">
            <summary>
            Adds a new item.
            </summary>
            <param name="item">Item to add.</param>
        </member>
        <member name="T:CK.RouteConfig.Impl.ProtoResolver">
            <summary>
            Internal class used by <see cref="T:CK.RouteConfig.Impl.RouteResolver"/>.
            </summary>
        </member>
        <member name="T:CK.RouteConfig.Impl.RouteResolver">
            <summary>
            Internal class used by <see cref="M:CK.RouteConfig.RouteConfiguration.Resolve(CK.Core.IActivityMonitor)"/>.
            </summary>
        </member>
        <member name="T:CK.RouteConfig.IRouteConfigurationLock">
            <summary>
            Enables routes configuration locking.
            Route obtained by <see cref="M:CK.RouteConfig.ConfiguredRouteHost`2.ObtainRoute(System.String)"/> are initally locked: they must be unlocked before a new configuration can be applied. 
            </summary>
        </member>
        <member name="M:CK.RouteConfig.IRouteConfigurationLock.Lock">
            <summary>
            Locks the configuration.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.IRouteConfigurationLock.Unlock">
            <summary>
            Unlocks the configuration.
            </summary>
        </member>
        <member name="T:CK.RouteConfig.MetaAddActionConfiguration">
            <summary>
            Declares one or more <see cref="T:CK.RouteConfig.ActionConfiguration"/> and inserts them with their names.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.MetaAddActionConfiguration.#ctor(CK.RouteConfig.ActionConfiguration,CK.RouteConfig.ActionConfiguration[])">
            <summary>
            Initializes a <see cref="T:CK.RouteConfig.MetaAddActionConfiguration"/> with at least one action to add.
            </summary>
            <param name="action">First, required, action to add.</param>
            <param name="otherActions">Optional other actions to add.</param>
        </member>
        <member name="P:CK.RouteConfig.MetaAddActionConfiguration.Actions">
            <summary>
            Gets the <see cref="T:CK.RouteConfig.ActionConfiguration"/>s that must be declared and inserted with their names.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.MetaAddActionConfiguration.Add(CK.RouteConfig.ActionConfiguration)">
            <summary>
            Adds an <see cref="T:CK.RouteConfig.ActionConfiguration"/>.
            </summary>
            <param name="action">The action to add.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.RouteConfig.MetaAddActionConfiguration.CheckValidity(System.String,CK.Core.IActivityMonitor)">
            <summary>
            Checks the validity: each action's name must be valid and each <see cref="M:CK.RouteConfig.ActionConfiguration.CheckValidity(System.String,CK.Core.IActivityMonitor)"/> must return true.
            </summary>
            <param name="routeName">Name of the route that contains this configuration.</param>
            <param name="monitor">Monitor to use to explain errors.</param>
            <returns>True if valid, false otherwise.</returns>
        </member>
        <member name="M:CK.RouteConfig.MetaAddActionConfiguration.Apply(CK.RouteConfig.Impl.IProtoRouteConfigurationContext)">
            <summary>
            Applies the configuration (first step) by <see cref="M:CK.RouteConfig.Impl.IProtoRouteConfigurationContext.DeclareAction(CK.RouteConfig.ActionConfiguration,System.Boolean)">declaring</see> all the actions
            and adding itself to the protoContext so that <see cref="M:CK.RouteConfig.MetaAddActionConfiguration.Apply(CK.RouteConfig.Impl.IRouteConfigurationContext)"/> will be called.
            </summary>
            <param name="protoContext">Enables context lookup and manipulation, exposes a <see cref="T:CK.Core.IActivityMonitor"/> to use.</param>
        </member>
        <member name="M:CK.RouteConfig.MetaAddActionConfiguration.Apply(CK.RouteConfig.Impl.IRouteConfigurationContext)">
            <summary>
            Applies the configuration (second step) by calling <see cref="M:CK.RouteConfig.Impl.IRouteConfigurationContext.AddDeclaredAction(System.String,System.String,System.Boolean)"/> for the <see cref="P:CK.RouteConfig.MetaAddActionConfiguration.Actions"/>.
            </summary>
            <param name="context">Enables context lookup and manipulation, exposes a <see cref="T:CK.Core.IActivityMonitor"/> to use.</param>
        </member>
        <member name="T:CK.RouteConfig.MetaDeclareActionConfiguration">
            <summary>
            Declares one or more <see cref="T:CK.RouteConfig.ActionConfiguration"/> but does not actually insert them.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.MetaDeclareActionConfiguration.#ctor(CK.RouteConfig.ActionConfiguration,CK.RouteConfig.ActionConfiguration[])">
            <summary>
            Initializes a <see cref="T:CK.RouteConfig.MetaDeclareActionConfiguration"/> with at least one action to declare.
            </summary>
            <param name="action">First, required, action to declare.</param>
            <param name="otherActions">Optional other actions to declare.</param>
        </member>
        <member name="P:CK.RouteConfig.MetaDeclareActionConfiguration.Actions">
            <summary>
            Gets the <see cref="T:CK.RouteConfig.ActionConfiguration"/>s that must be declared.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.MetaDeclareActionConfiguration.Declare(CK.RouteConfig.ActionConfiguration)">
            <summary>
            Declares an <see cref="T:CK.RouteConfig.ActionConfiguration"/>.
            </summary>
            <param name="action">The action to declare.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.RouteConfig.MetaDeclareActionConfiguration.CheckValidity(System.String,CK.Core.IActivityMonitor)">
            <summary>
            Checks the validity: each action's name must be valid and each <see cref="M:CK.RouteConfig.ActionConfiguration.CheckValidity(System.String,CK.Core.IActivityMonitor)"/> must return true.
            </summary>
            <param name="routeName">Name of the route that contains this configuration.</param>
            <param name="monitor">Monitor to use to explain errors.</param>
            <returns>True if valid, false otherwise.</returns>
        </member>
        <member name="M:CK.RouteConfig.MetaDeclareActionConfiguration.Apply(CK.RouteConfig.Impl.IProtoRouteConfigurationContext)">
            <summary>
            Applies the configuration (first step) by <see cref="M:CK.RouteConfig.Impl.IProtoRouteConfigurationContext.DeclareAction(CK.RouteConfig.ActionConfiguration,System.Boolean)">declaring</see> all the <see cref="P:CK.RouteConfig.MetaDeclareActionConfiguration.Actions"/>.
            </summary>
            <param name="protoContext">Enables context lookup and manipulation, exposes a <see cref="T:CK.Core.IActivityMonitor"/> to use.</param>
        </member>
        <member name="M:CK.RouteConfig.MetaDeclareActionConfiguration.Apply(CK.RouteConfig.Impl.IRouteConfigurationContext)">
            <summary>
            Never called: the first <see cref="M:CK.RouteConfig.MetaDeclareActionConfiguration.Apply(CK.RouteConfig.Impl.IProtoRouteConfigurationContext)"/> does not register this object
            since we have nothing more to do than declaring actions.
            </summary>
            <param name="context">Enables context lookup and manipulation, exposes a <see cref="T:CK.Core.IActivityMonitor"/> to use.</param>
        </member>
        <member name="T:CK.RouteConfig.MetaDeclareRouteConfiguration">
            <summary>
            Declares a new <see cref="T:CK.RouteConfig.SubRouteConfiguration"/>.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.MetaDeclareRouteConfiguration.#ctor(CK.RouteConfig.SubRouteConfiguration)">
            <summary>
            Initializes a new <see cref="T:CK.RouteConfig.MetaDeclareRouteConfiguration"/> bound to a <see cref="T:CK.RouteConfig.SubRouteConfiguration"/>.
            </summary>
            <param name="route">Subordinated route configuration.</param>
        </member>
        <member name="P:CK.RouteConfig.MetaDeclareRouteConfiguration.RouteConfiguration">
            <summary>
            Gets the subordinated route configuration.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.MetaDeclareRouteConfiguration.CheckValidity(System.String,CK.Core.IActivityMonitor)">
            <summary>
            Always true.
            </summary>
            <param name="routeName">Name of the route that contains this configuration.</param>
            <param name="monitor">Monitor to use to explain errors.</param>
            <returns>Always true.</returns>
        </member>
        <member name="M:CK.RouteConfig.MetaDeclareRouteConfiguration.Apply(CK.RouteConfig.Impl.IProtoRouteConfigurationContext)">
            <summary>
            Applies the configuration (first step) by calling <see cref="M:CK.RouteConfig.Impl.IProtoRouteConfigurationContext.AddRoute(CK.RouteConfig.SubRouteConfiguration)"/>.
            </summary>
            <param name="protoContext">Enables context lookup and manipulation, exposes a <see cref="T:CK.Core.IActivityMonitor"/> to use.</param>
        </member>
        <member name="M:CK.RouteConfig.MetaDeclareRouteConfiguration.Apply(CK.RouteConfig.Impl.IRouteConfigurationContext)">
            <summary>
            Never called: the first <see cref="M:CK.RouteConfig.MetaDeclareRouteConfiguration.Apply(CK.RouteConfig.Impl.IProtoRouteConfigurationContext)"/> does not register this object
            since we have nothing more to do than adding the route.
            </summary>
            <param name="context">Enables context lookup and manipulation, exposes a <see cref="T:CK.Core.IActivityMonitor"/> to use.</param>
        </member>
        <member name="T:CK.RouteConfig.MetaInsertActionConfiguration">
            <summary>
            Enables inserting in the route an already declared action.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.MetaInsertActionConfiguration.#ctor(System.String,System.String)">
            <summary>
            Initializes a new <see cref="T:CK.RouteConfig.MetaInsertActionConfiguration"/> with the name of the action and the name of the 
            previously declared action.
            </summary>
            <param name="name">Name of the action to insert.</param>
            <param name="declarationName">Declared action's name.</param>
        </member>
        <member name="P:CK.RouteConfig.MetaInsertActionConfiguration.DeclaredName">
            <summary>
            Gets or sets the name of the declared action. Never null: defaults to <see cref="F:System.String.Empty"/>.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.MetaInsertActionConfiguration.CheckValidity(System.String,CK.Core.IActivityMonitor)">
            <summary>
            Checks the validity: name and <see cref="P:CK.RouteConfig.MetaInsertActionConfiguration.DeclaredName"/> must be valid.
            </summary>
            <param name="routeName">Name of the route that contains this configuration.</param>
            <param name="monitor">Monitor to use to explain errors.</param>
            <returns>True if valid, false otherwise.</returns>
        </member>
        <member name="M:CK.RouteConfig.MetaInsertActionConfiguration.Apply(CK.RouteConfig.Impl.IRouteConfigurationContext)">
            <summary>
            Calls <see cref="M:CK.RouteConfig.Impl.IRouteConfigurationContext.AddDeclaredAction(System.String,System.String,System.Boolean)"/> to add the <see cref="P:CK.RouteConfig.MetaInsertActionConfiguration.DeclaredName"/> with this name.
            </summary>
            <param name="context">Enables context lookup and manipulation, exposes a <see cref="T:CK.Core.IActivityMonitor"/> to use.</param>
        </member>
        <member name="T:CK.RouteConfig.MetaOverrideActionConfiguration">
            <summary>
            Overrides, redefines, one or more <see cref="T:CK.RouteConfig.ActionConfiguration"/>: based on their names they will replace previously defined actions.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.MetaOverrideActionConfiguration.#ctor(CK.RouteConfig.ActionConfiguration,CK.RouteConfig.ActionConfiguration[])">
            <summary>
            Initializes a new <see cref="T:CK.RouteConfig.MetaOverrideActionConfiguration"/> with at least one action to override.
            </summary>
            <param name="action">First, required, action to override.</param>
            <param name="otherActions">Optional other actions to override.</param>
        </member>
        <member name="P:CK.RouteConfig.MetaOverrideActionConfiguration.Actions">
            <summary>
            Gets the <see cref="T:CK.RouteConfig.ActionConfiguration"/>s that must be overridden.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.MetaOverrideActionConfiguration.Override(CK.RouteConfig.ActionConfiguration)">
            <summary>
            Adds an <see cref="T:CK.RouteConfig.ActionConfiguration"/> that must be overridden.
            </summary>
            <param name="action">The action that will override an existing one with the same name.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.RouteConfig.MetaOverrideActionConfiguration.CheckValidity(System.String,CK.Core.IActivityMonitor)">
            <summary>
            Checks the validity: each action's name must be valid and each <see cref="M:CK.RouteConfig.ActionConfiguration.CheckValidity(System.String,CK.Core.IActivityMonitor)"/> must return true.
            </summary>
            <param name="routeName">Name of the route that contains this configuration.</param>
            <param name="monitor">Monitor to use to explain errors.</param>
            <returns>True if valid, false otherwise.</returns>
        </member>
        <member name="M:CK.RouteConfig.MetaOverrideActionConfiguration.Apply(CK.RouteConfig.Impl.IProtoRouteConfigurationContext)">
            <summary>
            This method declares the <see cref="P:CK.RouteConfig.MetaOverrideActionConfiguration.Actions"/> as being overridden by calling <see cref="M:CK.RouteConfig.Impl.IProtoRouteConfigurationContext.DeclareAction(CK.RouteConfig.ActionConfiguration,System.Boolean)"/>
            with the overridden parameter sets to true.
            </summary>
            <param name="protoContext">The temporary context used to build the routes.</param>
        </member>
        <member name="M:CK.RouteConfig.MetaOverrideActionConfiguration.Apply(CK.RouteConfig.Impl.IRouteConfigurationContext)">
            <summary>
            Never called: the first <see cref="M:CK.RouteConfig.MetaOverrideActionConfiguration.Apply(CK.RouteConfig.Impl.IProtoRouteConfigurationContext)"/> does not register this object
            since we have nothing more to do than declaring overridden actions.
            </summary>
            <param name="context">Enables context lookup and manipulation, exposes a <see cref="T:CK.Core.IActivityMonitor"/> to use.</param>
        </member>
        <member name="T:CK.RouteConfig.MetaRemoveActionConfiguration">
            <summary>
            Removes one or more actions that have been inserted before.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.MetaRemoveActionConfiguration.#ctor(System.String,System.String[])">
            <summary>
            Initializes a <see cref="T:CK.RouteConfig.MetaRemoveActionConfiguration"/> with at least one action to remove.
            </summary>
            <param name="nameToRemove">Name of the first action to remove.</param>
            <param name="otherNames">Other names to remove.</param>
        </member>
        <member name="P:CK.RouteConfig.MetaRemoveActionConfiguration.NamesToRemove">
            <summary>
            Gets the names of the actions that must be removed.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.MetaRemoveActionConfiguration.CheckValidity(System.String,CK.Core.IActivityMonitor)">
            <summary>
            Check the configuration validity: always true.
            </summary>
            <param name="routeName">Name of the route that contains this configuration.</param>
            <param name="monitor">Monitor to use to explain errors.</param>
            <returns>Always true.</returns>
        </member>
        <member name="M:CK.RouteConfig.MetaRemoveActionConfiguration.Remove(System.String)">
            <summary>
            Adds a name to the <see cref="P:CK.RouteConfig.MetaRemoveActionConfiguration.NamesToRemove"/>.
            </summary>
            <param name="nameToRemove">New name to remove.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.RouteConfig.MetaRemoveActionConfiguration.Apply(CK.RouteConfig.Impl.IRouteConfigurationContext)">
            <summary>
            Applies this configuration by removing all actions in <see cref="P:CK.RouteConfig.MetaRemoveActionConfiguration.NamesToRemove"/> from the context.
            </summary>
            <param name="context">The context to modify.</param>
        </member>
        <member name="T:CK.RouteConfig.RouteActionFactory`2">
            <summary>
            Factory for actual actions from <see cref="T:CK.RouteConfig.ActionConfiguration"/> objects that enables
            the <see cref="T:CK.RouteConfig.ConfiguredRouteHost`2"/> to create new actions and new final routes whenever its configuration changed.
            </summary>
            <typeparam name="TAction">Actual type of the actions. The only constraint is that it must be a reference type.</typeparam>
            <typeparam name="TRoute">Route class that encapsulates actions.</typeparam>
        </member>
        <member name="M:CK.RouteConfig.RouteActionFactory`2.#ctor">
            <summary>
            Initializes a new factory.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.RouteActionFactory`2.DoCreateEmptyFinalRoute">
            <summary>
            Must be implemented to return an empty final route.
            This empty final route is used when no configuration exists or if an error occurred while 
            setting a new configuration.
            </summary>
            <returns>An empty route. Can be a static shared (immutable) object.</returns>
        </member>
        <member name="M:CK.RouteConfig.RouteActionFactory`2.DoInitialize">
            <summary>
            Must be implemented to initialize any required shared objects for building new actions and routes.
            This is called once prior to any call to other methods of this factory.
            Default implementation does nothing.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.RouteActionFactory`2.DoCreate(CK.Core.IActivityMonitor,CK.RouteConfig.IRouteConfigurationLock,CK.RouteConfig.ActionConfiguration)">
            <summary>
            Must be implemented to create a <typeparamref name="TAction"/> from a <see cref="T:CK.RouteConfig.ActionConfiguration"/> object
            that is guaranteed to not be a composite (a parallel or a sequence).
            </summary>
            <param name="monitor">Monitor to use if needed.</param>
            <param name="configLock">
            Configuration lock. It must not be solicited during the creation of the action: an action that delay
            its work can keep a reference to it and use it when needed.
            </param>
            <param name="c">Configuration of the action.</param>
            <returns>The created action.</returns>
        </member>
        <member name="M:CK.RouteConfig.RouteActionFactory`2.DoCreateParallel(CK.Core.IActivityMonitor,CK.RouteConfig.IRouteConfigurationLock,CK.RouteConfig.ActionParallelConfiguration,`0[])">
            <summary>
            Must me implemented to create a parallel action.
            </summary>
            <param name="monitor">Monitor to use if needed.</param>
            <param name="configLock">
            Configuration lock. It must not be solicited during the creation of the parallel: if the parallel delays
            its work, it can keep a reference to it and use it as needed.
            </param>
            <param name="c">Configuration of the parallel action.</param>
            <param name="children">Array of already created children action.</param>
            <returns>A parallel action.</returns>
        </member>
        <member name="M:CK.RouteConfig.RouteActionFactory`2.DoCreateSequence(CK.Core.IActivityMonitor,CK.RouteConfig.IRouteConfigurationLock,CK.RouteConfig.ActionSequenceConfiguration,`0[])">
            <summary>
            Must me implemented to create a sequence action.
            </summary>
            <param name="monitor">Monitor to use if needed.</param>
            <param name="configLock">
            Configuration lock. It must not be solicited during the creation of the sequence: a sequence that delays
            its work can keep a reference to it and use it as needed.
            </param>
            <param name="c">Configuration of the sequence action.</param>
            <param name="children">Array of already created children action.</param>
            <returns>A sequence action.</returns>
        </member>
        <member name="M:CK.RouteConfig.RouteActionFactory`2.DoCreateFinalRoute(CK.Core.IActivityMonitor,CK.RouteConfig.IRouteConfigurationLock,`0[],System.String,System.Object,System.Collections.Generic.IReadOnlyList{`1})">
            <summary>
            Must be implemented to create the final route class that encapsulates the array of actions of a route. 
            </summary>
            <param name="monitor">Monitor to use if needed to comment route creation.</param>
            <param name="configLock">
            Configuration lock. It must not be solicited during the creation of the route: a route that delays
            its work can keep a reference to it and use it as needed.
            </param>
            <param name="actions">Array of actions for the route.</param>
            <param name="configurationName">The <see cref="T:CK.RouteConfig.RouteConfiguration"/> name.</param>
            <param name="configData">Configuration data of the route.</param>
            <param name="routePath">Path to this route: parent route objects are already created.</param>
            <returns>Final route actions encapsulation.</returns>
        </member>
        <member name="M:CK.RouteConfig.RouteActionFactory`2.DoUninitialize(System.Boolean)">
            <summary>
            Must be implemented to cleanup any resources (if any) once new actions and routes have been created.
            This is always called (even if an error occurred). 
            Default implementation does nothing.
            </summary>
            <param name="success">True on success, false if creation of routes has failed.</param>
        </member>
        <member name="T:CK.RouteConfig.RouteConfiguration">
            <summary>
            Primary configuration object that contains multiple <see cref="T:CK.RouteConfig.SubRouteConfiguration"/>s and <see cref="T:CK.RouteConfig.ActionConfiguration"/>s.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.RouteConfiguration.#ctor">
            <summary>
            Initializes a new root <see cref="T:CK.RouteConfig.RouteConfiguration"/>.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.RouteConfiguration.#ctor(System.String)">
            <summary>
            Initializes a specialized <see cref="T:CK.RouteConfig.RouteConfiguration"/>.
            </summary>
            <param name="name">Name of the route. Can not be null.</param>
        </member>
        <member name="P:CK.RouteConfig.RouteConfiguration.Name">
            <summary>
            Gets the name of this configuration.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.RouteConfiguration.ConfigData">
            <summary>
            Gets or sets any configuration data for this route.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.RouteConfiguration.Namespace">
            <summary>
            Gets or sets an optional namespace for this route: declared <see cref="T:CK.RouteConfig.SubRouteConfiguration"/>
            are automatically prefixed with this namespace. Never null.
            This namespace has no effect on any <see cref="P:CK.RouteConfig.ActionConfiguration.Name"/>.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.RouteConfiguration.Configurations">
            <summary>
            Gets the content of this configuration: a list of <see cref="T:CK.RouteConfig.Impl.MetaConfiguration"/> that 
            encapsulates <see cref="T:CK.RouteConfig.ActionConfiguration"/> and/or <see cref="T:CK.RouteConfig.SubRouteConfiguration"/>.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.RouteConfiguration.AddAction(CK.RouteConfig.ActionConfiguration,CK.RouteConfig.ActionConfiguration[])">
            <summary>
            Adds one or more <see cref="T:CK.RouteConfig.ActionConfiguration"/>.
            </summary>
            <param name="a">The first configuration.</param>
            <param name="otherActions">Optional other configurations.</param>
            <returns>This object.</returns>
        </member>
        <member name="M:CK.RouteConfig.RouteConfiguration.DeclareAction(CK.RouteConfig.ActionConfiguration,CK.RouteConfig.ActionConfiguration[])">
            <summary>
            Declares one or more <see cref="T:CK.RouteConfig.ActionConfiguration"/>. It can be inserted later thanks to <see cref="M:CK.RouteConfig.RouteConfiguration.InsertAction(System.String,System.String)"/>.
            </summary>
            <param name="a">The first configuration to declare.</param>
            <param name="otherActions">Optional other configurations to declare.</param>
            <returns>This object.</returns>
        </member>
        <member name="M:CK.RouteConfig.RouteConfiguration.OverrideAction(CK.RouteConfig.ActionConfiguration,CK.RouteConfig.ActionConfiguration[])">
            <summary>
            Overrides one or more existing <see cref="T:CK.RouteConfig.ActionConfiguration"/> (lookup is done by name).
            </summary>
            <param name="a">The first configuration to override.</param>
            <param name="otherActions">Optional other configurations to override.</param>
            <returns>This object.</returns>
        </member>
        <member name="M:CK.RouteConfig.RouteConfiguration.RemoveAction(System.String,System.String[])">
            <summary>
            Removes one or more existing <see cref="T:CK.RouteConfig.ActionConfiguration"/>.
            </summary>
            <param name="name">The first configuration name to remove.</param>
            <param name="otherNames">Optional other configurations' name to remove.</param>
            <returns>This object.</returns>
        </member>
        <member name="M:CK.RouteConfig.RouteConfiguration.InsertAction(System.String,System.String)">
            <summary>
            Inserts a previously <see cref="M:CK.RouteConfig.RouteConfiguration.DeclareAction(CK.RouteConfig.ActionConfiguration,CK.RouteConfig.ActionConfiguration[])">declared</see> action.
            </summary>
            <param name="name">The name of the inserted configuration.</param>
            <param name="declarationName">The name of the previously declared action.</param>
            <returns>This object.</returns>
        </member>
        <member name="M:CK.RouteConfig.RouteConfiguration.DeclareRoute(CK.RouteConfig.SubRouteConfiguration)">
            <summary>
            Declare a new subordinated route.
            </summary>
            <param name="route">The subordinated route configuration.</param>
            <returns>This object.</returns>
        </member>
        <member name="M:CK.RouteConfig.RouteConfiguration.AddMeta(CK.RouteConfig.Impl.MetaConfiguration)">
            <summary>
            Protected method to actually add any <see cref="T:CK.RouteConfig.Impl.MetaConfiguration"/> object.
            </summary>
            <param name="m">A meta configuration to add.</param>
        </member>
        <member name="M:CK.RouteConfig.RouteConfiguration.Resolve(CK.Core.IActivityMonitor)">
            <summary>
            Attempts to resolve the configuration. Null if an error occurred.
            </summary>
            <param name="monitor">Monitor to use. Must not be null.</param>
            <returns>Null or a set of resolved route configuration.</returns>
        </member>
        <member name="T:CK.RouteConfig.RouteConfigurationResolved">
            <summary>
            Describes the configuration of a route once configuration is resolved (actions and subordinate routes are known).
            </summary>
        </member>
        <member name="P:CK.RouteConfig.RouteConfigurationResolved.Name">
            <summary>
            Gets the name of the route.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.RouteConfigurationResolved.ConfigData">
            <summary>
            Gets the configuration data object associated to this route.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.RouteConfigurationResolved.SubRoutes">
            <summary>
            Gets the subordinated routes that this route contains.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.RouteConfigurationResolved.ActionsResolved">
            <summary>
            Gets the actions that apply to this route.
            </summary>
        </member>
        <member name="T:CK.RouteConfig.RouteConfigurationResult">
            <summary>
            Encapsulates the resolution of routes configuration: the <see cref="M:CK.RouteConfig.RouteConfiguration.Resolve(CK.Core.IActivityMonitor)"/> method computes it.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.RouteConfigurationResult.Root">
            <summary>
            Gets the resolved root route.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.RouteConfigurationResult.AllSubRoutes">
            <summary>
            Gets all the subordinated routes.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.RouteConfigurationResult.FindSubRouteByName(System.String)">
            <summary>
            Finds a subordinated route by its name.
            </summary>
            <param name="name">Name of the route.</param>
            <returns>The route or null if it does not exist.</returns>
        </member>
        <member name="T:CK.RouteConfig.SubRouteConfiguration">
            <summary>
            Captures subordinated <see cref="T:CK.RouteConfig.RouteConfiguration"/>: a SubRouteConfiguration <see cref="P:CK.RouteConfig.SubRouteConfiguration.ImportParentActions"/> and <see cref="P:CK.RouteConfig.SubRouteConfiguration.ImportParentDeclaredActionsAbove"/> by default
            and defines a <see cref="P:CK.RouteConfig.SubRouteConfiguration.RoutePredicate"/>.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.SubRouteConfiguration.RoutePredicate">
            <summary>
            Gets or sets the filter for this route.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.SubRouteConfiguration.ImportParentActions">
            <summary>
            Gets or sets whether actions inserted above at the parent level initially apply to this route.
            Defaults to true: by default, a route inherits the actions of its parent, setting this to false, makes this route initially empty.
            When <see cref="P:CK.RouteConfig.SubRouteConfiguration.ImportParentDeclaredActionsAbove"/> is set to false, this is always false (one can not reuse actions for which declaration are not available).
            </summary>
        </member>
        <member name="P:CK.RouteConfig.SubRouteConfiguration.ImportParentDeclaredActionsAbove">
            <summary>
            Gets or sets whether actions declared by parent routes before this one are available to this route: <see cref="M:CK.RouteConfig.SubRouteConfiguration.InsertAction(System.String,System.String)"/> can reference
            any action declared before (and above).
            Defaults to true: by default a sub route can reuse action declared before and above. Setting this to false implies that <see cref="P:CK.RouteConfig.SubRouteConfiguration.ImportParentActions"/>
            is also false.
            </summary>
        </member>
        <member name="M:CK.RouteConfig.SubRouteConfiguration.AddAction(CK.RouteConfig.ActionConfiguration,CK.RouteConfig.ActionConfiguration[])">
            <summary>
            Adds one or more actions.
            </summary>
            <param name="a">Action to add.</param>
            <param name="otherActions">Optional other actions to add.</param>
            <returns>This <see cref="T:CK.RouteConfig.SubRouteConfiguration"/> to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.RouteConfig.SubRouteConfiguration.DeclareAction(CK.RouteConfig.ActionConfiguration,CK.RouteConfig.ActionConfiguration[])">
            <summary>
            Declares one or more actions.
            </summary>
            <param name="a">Action to declare.</param>
            <param name="otherActions">Optional other actions to declare.</param>
            <returns>This <see cref="T:CK.RouteConfig.SubRouteConfiguration"/> to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.RouteConfig.SubRouteConfiguration.OverrideAction(CK.RouteConfig.ActionConfiguration,CK.RouteConfig.ActionConfiguration[])">
            <summary>
            Overrides one or more existing actions.
            <see cref="P:CK.RouteConfig.ActionConfiguration.Name"/> is the key.
            </summary>
            <param name="a">Action to to override.</param>
            <param name="otherActions">Optional other actions to override.</param>
            <returns>This <see cref="T:CK.RouteConfig.SubRouteConfiguration"/> to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.RouteConfig.SubRouteConfiguration.RemoveAction(System.String,System.String[])">
            <summary>
            Removes one or more actions by name.
            </summary>
            <param name="name">Name of the action to remove.</param>
            <param name="otherNames">Optional other actions' name to remove.</param>
            <returns>This <see cref="T:CK.RouteConfig.SubRouteConfiguration"/> to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.RouteConfig.SubRouteConfiguration.InsertAction(System.String,System.String)">
            <summary>
            Inserts one action that have been previously <see cref="M:CK.RouteConfig.SubRouteConfiguration.DeclareAction(CK.RouteConfig.ActionConfiguration,CK.RouteConfig.ActionConfiguration[])">declared</see>.
            </summary>
            <param name="name">Name of the action to insert.</param>
            <param name="declarationName">Name of the declared action.</param>
            <returns>This <see cref="T:CK.RouteConfig.SubRouteConfiguration"/> to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.RouteConfig.SubRouteConfiguration.DeclareRoute(CK.RouteConfig.SubRouteConfiguration)">
            <summary>
            Declares a subordinated route.
            </summary>
            <param name="channel">Configuration of the route.</param>
            <returns>This <see cref="T:CK.RouteConfig.SubRouteConfiguration"/> to enable fluent syntax.</returns>
        </member>
        <member name="T:CK.RouteConfig.SubRouteConfigurationResolved">
            <summary>
            Describes the configuration of a subordinated route once configuration is resolved.
            </summary>
        </member>
        <member name="P:CK.RouteConfig.SubRouteConfigurationResolved.RoutePredicate">
            <summary>
            Gets the filter that route must respect to enter this sub route.
            </summary>
        </member>
        <member name="T:SimpleGitVersionInfoAttribute">
            <summary>
            Automatically generated by SimpleGitVersionTask 5.0.0-delta.2. 
            </summary>
        </member>
    </members>
</doc>
